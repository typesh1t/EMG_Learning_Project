# EMGè‚Œç”µä¿¡å·å­¦ä¹ è®¡åˆ’ï¼ˆé«˜ä¸­å›½é™…ç”Ÿç‰ˆï¼‰

> **é€‚ç”¨å¯¹è±¡**: 0åŸºç¡€é«˜ä¸­å›½é™…ç”Ÿ
> **å­¦ä¹ å‘¨æœŸ**: 8-10å‘¨
> **æœ€ç»ˆç›®æ ‡**: ä»é›¶å¼€å§‹æŒæ¡EMGä¿¡å·é‡‡é›†ã€å¤„ç†ã€åˆ†æï¼Œå¹¶å®Œæˆä¸€ä¸ªå®æ—¶æ‰‹åŠ¿è¯†åˆ«é¡¹ç›®

---

## ğŸ“‹ è¯¾ç¨‹æ¦‚è§ˆ

æœ¬è¯¾ç¨‹é‡‡ç”¨**ç†è®º+å®è·µ**çš„æ•™å­¦æ–¹å¼ï¼Œé€šè¿‡å¾ªåºæ¸è¿›çš„7ä¸ªé˜¶æ®µï¼Œå¸®åŠ©å­¦ç”Ÿä»é›¶åŸºç¡€é€æ­¥æŒæ¡EMGè‚Œç”µä¿¡å·å¤„ç†çš„å®Œæ•´æŠ€èƒ½é“¾ã€‚

### æ ¸å¿ƒå­¦ä¹ è·¯å¾„
```
ç†è®ºè®¤çŸ¥ â†’ è®¾å¤‡äº†è§£ â†’ ä¿¡å·ç‰¹å¾ â†’ Pythonç¼–ç¨‹ â†’ ä¿¡å·å¤„ç† â†’ æ¨¡å¼è¯†åˆ« â†’ å®æ—¶ç³»ç»Ÿ
```

---

## ğŸ¯ ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€è®¤çŸ¥ï¼ˆç¬¬1-2å‘¨ï¼‰

### å­¦ä¹ ç›®æ ‡
- ç†è§£ä»€ä¹ˆæ˜¯EMGè‚Œç”µä¿¡å·
- äº†è§£EMGçš„å®é™…åº”ç”¨åœºæ™¯
- è®¤è¯†EMGé‡‡é›†è®¾å¤‡çš„åŸºæœ¬ç»„æˆ

### 1.1 ä»€ä¹ˆæ˜¯EMGï¼Ÿ

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- è‚Œç”µä¿¡å·ï¼ˆElectromyography, EMGï¼‰æ˜¯è‚Œè‚‰æ”¶ç¼©æ—¶äº§ç”Ÿçš„ç”Ÿç‰©ç”µä¿¡å·
- é€šè¿‡çš®è‚¤è¡¨é¢çš„ç”µæå¯ä»¥æ£€æµ‹åˆ°è¿™äº›å¾®å¼±çš„ç”µä¿¡å·
- ä¿¡å·å¹…åº¦èŒƒå›´ï¼š50å¾®ä¼ï¼ˆÎ¼Vï¼‰åˆ° 5æ¯«ä¼ï¼ˆmVï¼‰

**è‚Œè‚‰ç”µä¿¡å·çš„äº§ç”Ÿæœºåˆ¶**ï¼š
1. å¤§è„‘å‘å‡ºè¿åŠ¨æŒ‡ä»¤
2. ç¥ç»ä¼ å¯¼ä¿¡å·åˆ°è‚Œè‚‰
3. è‚Œè‚‰ç»†èƒè†œå‘ç”Ÿç”µä½å˜åŒ–ï¼ˆåŠ¨ä½œç”µä½ï¼‰
4. å¤šä¸ªè‚Œè‚‰ç»†èƒçš„ç”µæ´»åŠ¨å åŠ å½¢æˆEMGä¿¡å·

**å®é™…åº”ç”¨åœºæ™¯**ï¼š
- ğŸ¦¾ **åŒ»ç–—åº·å¤**: è‚Œè‚‰åŠŸèƒ½è¯„ä¼°ã€åº·å¤è®­ç»ƒç›‘æµ‹
- ğŸ¤– **å‡è‚¢æ§åˆ¶**: é€šè¿‡EMGä¿¡å·æ§åˆ¶æœºæ¢°å‡è‚¢
- ğŸ® **äººæœºäº¤äº’**: æ‰‹åŠ¿è¯†åˆ«ã€æ¸¸æˆæ§åˆ¶ã€VR/ARäº¤äº’
- ğŸƒ **è¿åŠ¨ç§‘å­¦**: è¿åŠ¨å‘˜è®­ç»ƒç›‘æµ‹ã€ç–²åŠ³è¯„ä¼°
- ğŸ”¬ **ç”Ÿç‰©åé¦ˆ**: å‹åŠ›ç®¡ç†ã€å§¿åŠ¿çŸ«æ­£

**æ•™å­¦æ´»åŠ¨**ï¼š
- è§‚çœ‹EMGåº”ç”¨æ¡ˆä¾‹è§†é¢‘ï¼ˆå‡è‚¢ã€æ¸¸æˆæ§åˆ¶ç­‰ï¼‰
- è®¨è®ºï¼šä½ æœ€æ„Ÿå…´è¶£çš„3ä¸ªEMGåº”ç”¨åœºæ™¯æ˜¯ä»€ä¹ˆï¼Ÿ
- ä½œä¸šï¼šç”¨ç®€å•å›¾ç¤ºç”»å‡º"å¤§è„‘â†’è‚Œè‚‰â†’EMGä¿¡å·"çš„ä¼ å¯¼è¿‡ç¨‹

---

### 1.2 EMGé‡‡é›†è®¾å¤‡è®¤è¯†

**EMGé‡‡é›†ç³»ç»Ÿçš„ç»„æˆ**ï¼š
```
è‚Œè‚‰ â†’ ç”µæ â†’ æ”¾å¤§å™¨ â†’ æ»¤æ³¢å™¨ â†’ ADCè½¬æ¢å™¨ â†’ è®¡ç®—æœº
```

**å…³é”®ç»„ä»¶è¯¦è§£**ï¼š

1. **ç”µæï¼ˆElectrodeï¼‰**
   - **è¡¨é¢ç”µæ**: æ— åˆ›ï¼Œè´´åœ¨çš®è‚¤è¡¨é¢ï¼ˆæœ¬è¯¾ç¨‹ä½¿ç”¨ï¼‰
   - **é’ˆç”µæ**: ä¾µå…¥å¼ï¼Œæ’å…¥è‚Œè‚‰ï¼ˆåŒ»ç–—ç”¨é€”ï¼‰
   - ç”µæç±»å‹ï¼šé“¶/æ°¯åŒ–é“¶ï¼ˆAg/AgClï¼‰ç”µæï¼Œæ¹¿ç”µææˆ–å¹²ç”µæ

2. **æ”¾å¤§å™¨ï¼ˆAmplifierï¼‰**
   - ä½œç”¨ï¼šå°†å¾®å¼±çš„Î¼Vçº§ä¿¡å·æ”¾å¤§åˆ°å¯å¤„ç†çš„èŒƒå›´
   - å…¸å‹å¢ç›Šï¼š1000-10000å€
   - å·®åˆ†æ”¾å¤§ï¼šå‡å°‘å…±æ¨¡å¹²æ‰°

3. **æ»¤æ³¢å™¨ï¼ˆFilterï¼‰**
   - ç¡¬ä»¶æ»¤æ³¢ï¼šåˆæ­¥å»é™¤å™ªå£°
   - å…¸å‹é¢‘ç‡èŒƒå›´ï¼š20-500Hz

4. **ADCï¼ˆæ¨¡æ•°è½¬æ¢å™¨ï¼‰**
   - å°†æ¨¡æ‹Ÿä¿¡å·è½¬æ¢ä¸ºæ•°å­—ä¿¡å·
   - é‡‡æ ·ç‡ï¼š1000-2000 Hzï¼ˆå¸¸ç”¨ï¼‰
   - åˆ†è¾¨ç‡ï¼š12-24ä½

5. **å¤šé€šé“é‡‡é›†**
   - åŒæ—¶ä»å¤šä¸ªè‚Œè‚‰éƒ¨ä½é‡‡é›†ä¿¡å·
   - å¸¸è§é…ç½®ï¼š2ã€4ã€8ã€16é€šé“
   - ç”¨é€”ï¼šç›‘æµ‹å¤šå—è‚Œè‚‰çš„ååŒä½œç”¨

**å¸¸è§EMGè®¾å¤‡ä»‹ç»**ï¼š

| è®¾å¤‡åç§° | é€šé“æ•° | ä»·æ ¼èŒƒå›´ | é€‚ç”¨åœºæ™¯ |
|---------|-------|---------|---------|
| Arduino + è‚Œç”µä¼ æ„Ÿå™¨ | 1-2 | $30-50 | å…¥é—¨å­¦ä¹  |
| MyoWare Sensor | 1 | $40 | æ•™å­¦å®éªŒ |
| OpenBCI Cyton | 8 | $500 | ç ”ç©¶çº§åº”ç”¨ |
| Myo Armband | 8 | $200ï¼ˆäºŒæ‰‹ï¼‰| æ‰‹åŠ¿è¯†åˆ« |
| Delsys Trigno | 16+ | $10,000+ | ä¸“ä¸šç ”ç©¶ |

**é‡è¦å‚æ•°ç†è§£**ï¼š
- **é‡‡æ ·ç‡ï¼ˆSampling Rateï¼‰**: æ¯ç§’é‡‡é›†å¤šå°‘ä¸ªæ•°æ®ç‚¹ï¼Œå•ä½Hz
  - å¤ªä½ï¼šä¸¢å¤±ä¿¡å·ç»†èŠ‚
  - å¤ªé«˜ï¼šæ•°æ®é‡å¤§ï¼Œå¤„ç†è´Ÿæ‹…é‡
  - æ¨èï¼š1000-2000 Hz

- **å¢ç›Šï¼ˆGainï¼‰**: ä¿¡å·æ”¾å¤§å€æ•°
  - å¤ªå°ï¼šä¿¡å·å¤ªå¼±ï¼Œæ·¹æ²¡åœ¨å™ªå£°ä¸­
  - å¤ªå¤§ï¼šä¿¡å·æº¢å‡ºï¼Œå¤±çœŸ
  - éœ€è¦æ ¹æ®å®é™…ä¿¡å·å¼ºåº¦è°ƒæ•´

- **å¸¦å®½ï¼ˆBandwidthï¼‰**: è®¾å¤‡èƒ½é‡‡é›†çš„é¢‘ç‡èŒƒå›´
  - EMGä¸»è¦èƒ½é‡é›†ä¸­åœ¨20-500Hz
  - è®¾å¤‡å¸¦å®½åº”è¦†ç›–è¿™ä¸ªèŒƒå›´

**å®è·µä»»åŠ¡**ï¼š
1. ç»˜åˆ¶ä¸€å¼ EMGé‡‡é›†ç³»ç»Ÿçš„å®Œæ•´æµç¨‹å›¾
2. æ ‡æ³¨æ¯ä¸ªç»„ä»¶çš„ä½œç”¨
3. æŸ¥æ‰¾å¹¶äº†è§£ä½ å°†ä½¿ç”¨çš„EMGè®¾å¤‡çš„å‚æ•°

**ä½œä¸š**ï¼š
- å®Œæˆ"EMGé‡‡é›†ç³»ç»Ÿç»„ä»¶è¯†åˆ«"å·¥ä½œè¡¨
- å›ç­”ï¼šä¸ºä»€ä¹ˆéœ€è¦å¤šé€šé“é‡‡é›†ï¼Ÿä¸¾ä¾‹è¯´æ˜

---

### ç¬¬1-2å‘¨å­¦ä¹ æ£€æŸ¥ç‚¹
âœ… èƒ½ç”¨è‡ªå·±çš„è¯è§£é‡Šä»€ä¹ˆæ˜¯EMGä¿¡å·
âœ… èƒ½è¯´å‡ºè‡³å°‘3ä¸ªEMGçš„å®é™…åº”ç”¨
âœ… èƒ½ç”»å‡ºEMGé‡‡é›†ç³»ç»Ÿçš„åŸºæœ¬æµç¨‹
âœ… ç†è§£é‡‡æ ·ç‡ã€å¢ç›Šã€å¸¦å®½çš„å«ä¹‰
âœ… çŸ¥é“è¡¨é¢ç”µæå’Œé’ˆç”µæçš„åŒºåˆ«

---

## ğŸ”¬ ç¬¬äºŒé˜¶æ®µï¼šä¿¡å·ç‰¹å¾è®¤çŸ¥ï¼ˆç¬¬3å‘¨ï¼‰

### å­¦ä¹ ç›®æ ‡
- è®¤è¯†çœŸå®EMGä¿¡å·çš„æ ·å­
- ç†è§£EMGä¿¡å·çš„æ—¶åŸŸå’Œé¢‘åŸŸç‰¹å¾
- è¯†åˆ«å¸¸è§çš„å™ªå£°å’Œå¹²æ‰°

### 2.1 EMGä¿¡å·çš„æ—¶åŸŸç‰¹å¾

**ä»€ä¹ˆæ˜¯æ—¶åŸŸï¼Ÿ**
- æ—¶åŸŸè¡¨ç¤ºä¿¡å·éšæ—¶é—´çš„å˜åŒ–
- æ¨ªè½´æ˜¯æ—¶é—´ï¼Œçºµè½´æ˜¯ä¿¡å·å¹…åº¦ï¼ˆç”µå‹ï¼‰

**EMGä¿¡å·çš„æ—¶åŸŸç‰¹ç‚¹**ï¼š
1. **éšæœºæ€§**: çœ‹èµ·æ¥åƒå™ªå£°ï¼Œæ²¡æœ‰æ˜æ˜¾çš„å‘¨æœŸæ€§
2. **çªå‘æ€§**: è‚Œè‚‰æ”¶ç¼©æ—¶ä¿¡å·å¹…åº¦çªç„¶å¢å¤§
3. **å¹…åº¦èŒƒå›´**:
   - é™æ¯çŠ¶æ€ï¼šæ¥è¿‘0ï¼ŒåŸºçº¿å™ªå£°çº¦5-20Î¼V
   - è½»åº¦æ”¶ç¼©ï¼š50-200Î¼V
   - å¼ºåŠ›æ”¶ç¼©ï¼š500Î¼V-5mV
4. **é›¶å‡å€¼**: ä¿¡å·åœ¨é›¶ç‚¹ä¸Šä¸‹æ³¢åŠ¨
5. **éå¹³ç¨³æ€§**: ä¿¡å·ç‰¹æ€§éšæ—¶é—´å˜åŒ–

**å…¸å‹EMGä¿¡å·å½¢æ€**ï¼š
```
é™æ¯ â†’ çªç„¶æ”¶ç¼© â†’ æŒç»­æ”¶ç¼© â†’ æ”¾æ¾

å¹…åº¦
  |
  |        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â† æŒç»­æ”¶ç¼©ï¼ˆé«˜å¹…åº¦ï¼‰
  |       â–ˆ            â–ˆ
  |     â–ˆâ–ˆ              â–ˆâ–ˆ
  |___â–ˆâ–ˆ__________________â–ˆâ–ˆ___  â† é™æ¯ï¼ˆä½å¹…åº¦ï¼‰
  |__________________________ æ—¶é—´
```

**é‡è¦æ—¶åŸŸå‚æ•°**ï¼š
- **MAVï¼ˆMean Absolute Valueï¼‰**: å¹³å‡ç»å¯¹å€¼ï¼Œåæ˜ æ•´ä½“æ´»åŠ¨å¼ºåº¦
- **RMSï¼ˆRoot Mean Squareï¼‰**: å‡æ–¹æ ¹ï¼Œåæ˜ ä¿¡å·çš„"æœ‰æ•ˆå€¼"
- **Variance**: æ–¹å·®ï¼Œåæ˜ ä¿¡å·çš„å˜åŒ–ç¨‹åº¦
- **Peak Amplitude**: å³°å€¼å¹…åº¦ï¼Œæœ€å¤§æ³¢åŠ¨
- **Zero Crossing Rate**: è¿‡é›¶ç‡ï¼Œä¿¡å·ç©¿è¿‡é›¶ç‚¹çš„é¢‘ç‡

---

### 2.2 EMGä¿¡å·çš„é¢‘åŸŸç‰¹å¾

**ä»€ä¹ˆæ˜¯é¢‘åŸŸï¼Ÿ**
- é¢‘åŸŸè¡¨ç¤ºä¿¡å·åŒ…å«å“ªäº›é¢‘ç‡æˆåˆ†
- é€šè¿‡**å‚…é‡Œå¶å˜æ¢ï¼ˆFFTï¼‰**ä»æ—¶åŸŸè½¬æ¢åˆ°é¢‘åŸŸ
- æ¨ªè½´æ˜¯é¢‘ç‡ï¼ˆHzï¼‰ï¼Œçºµè½´æ˜¯è¯¥é¢‘ç‡çš„åŠŸç‡/èƒ½é‡

**EMGä¿¡å·çš„é¢‘åŸŸç‰¹ç‚¹**ï¼š
1. **ä¸»è¦é¢‘ç‡èŒƒå›´**: 20-500 Hz
2. **èƒ½é‡é›†ä¸­åŒºåŸŸ**: 50-150 Hzï¼ˆå¤§éƒ¨åˆ†èƒ½é‡ï¼‰
3. **é¢‘è°±å½¢çŠ¶**:
   - ä½é¢‘ç«¯ï¼ˆ20-50Hzï¼‰ï¼šèƒ½é‡è¾ƒå°‘
   - ä¸­é¢‘æ®µï¼ˆ50-150Hzï¼‰ï¼šèƒ½é‡å³°å€¼
   - é«˜é¢‘ç«¯ï¼ˆ150-500Hzï¼‰ï¼šèƒ½é‡é€æ¸è¡°å‡

**ä¸ºä»€ä¹ˆéœ€è¦é¢‘åŸŸåˆ†æï¼Ÿ**
- è¯†åˆ«å™ªå£°ï¼ˆå·¥é¢‘å¹²æ‰°åœ¨50/60Hzæœ‰æ˜æ˜¾å³°å€¼ï¼‰
- è¯„ä¼°è‚Œè‚‰ç–²åŠ³ï¼ˆç–²åŠ³æ—¶é¢‘è°±å‘ä½é¢‘ç§»åŠ¨ï¼‰
- è®¾è®¡æ›´å¥½çš„æ»¤æ³¢å™¨

**é‡è¦é¢‘åŸŸå‚æ•°**ï¼š
- **Mean Frequency (MNF)**: å¹³å‡é¢‘ç‡ï¼Œé¢‘è°±çš„"é‡å¿ƒ"
- **Median Frequency (MDF)**: ä¸­å€¼é¢‘ç‡ï¼Œå°†åŠŸç‡è°±ä¸€åˆ†ä¸ºäºŒçš„é¢‘ç‡
- **Peak Frequency**: å³°å€¼é¢‘ç‡ï¼Œèƒ½é‡æœ€å¤§çš„é¢‘ç‡ç‚¹

**ç–²åŠ³çš„é¢‘åŸŸè¡¨ç°**ï¼š
```
æœªç–²åŠ³ï¼šé¢‘è°±å³°å€¼åœ¨è¾ƒé«˜é¢‘ç‡ï¼ˆ100-120Hzï¼‰
â†“
ç–²åŠ³ï¼šå³°å€¼å‘ä½é¢‘ç§»åŠ¨ï¼ˆ60-80Hzï¼‰ï¼Œé«˜é¢‘æˆåˆ†å‡å°‘
```

---

### 2.3 å™ªå£°å’Œå¹²æ‰°è¯†åˆ«

**å¸¸è§å™ªå£°ç±»å‹**ï¼š

1. **å·¥é¢‘å¹²æ‰°ï¼ˆPower Line Interferenceï¼‰**
   - æ¥æºï¼šç”µåŠ›çº¿è¾å°„ï¼ˆ50Hzæˆ–60Hzï¼Œå–å†³äºå›½å®¶ï¼‰
   - ç‰¹å¾ï¼šåœ¨é¢‘è°±ä¸Šå‡ºç°æ˜æ˜¾çš„50/60Hzå°–å³°åŠå…¶å€é¢‘ï¼ˆ100Hzã€150Hz...ï¼‰
   - è¡¨ç°ï¼šæ—¶åŸŸä¿¡å·ä¸Šå åŠ è§„å¾‹çš„æ­£å¼¦æ³¢
   - è§£å†³ï¼šé™·æ³¢æ»¤æ³¢å™¨ï¼ˆNotch Filterï¼‰

2. **è¿åŠ¨ä¼ªå½±ï¼ˆMotion Artifactsï¼‰**
   - æ¥æºï¼šç”µæç§»åŠ¨ã€å¯¼çº¿æ™ƒåŠ¨ã€èº«ä½“æ‘†åŠ¨
   - ç‰¹å¾ï¼šä½é¢‘å¤§å¹…åº¦æ³¢åŠ¨ï¼ˆ0-20Hzï¼‰
   - è¡¨ç°ï¼šåŸºçº¿æ¼‚ç§»ï¼Œçªç„¶çš„å¤§å¹…åº¦è·³å˜
   - è§£å†³ï¼šé«˜é€šæ»¤æ³¢å™¨ï¼ˆâ‰¥20Hzï¼‰ï¼Œç”µæå›ºå®š

3. **åŸºçº¿æ¼‚ç§»ï¼ˆBaseline Driftï¼‰**
   - æ¥æºï¼šç”µææ¥è§¦ä¸è‰¯ã€æ±—æ¶²å½±å“ã€å‘¼å¸è¿åŠ¨
   - ç‰¹å¾ï¼šç¼“æ…¢çš„ä½é¢‘è¶‹åŠ¿å˜åŒ–
   - è¡¨ç°ï¼šä¿¡å·æ•´ä½“ä¸Šå‡æˆ–ä¸‹é™
   - è§£å†³ï¼šé«˜é€šæ»¤æ³¢ã€å»è¶‹åŠ¿å¤„ç†

4. **ç”µææ¥è§¦å™ªå£°**
   - æ¥æºï¼šç”µæä¸çš®è‚¤æ¥è§¦é˜»æŠ—é«˜
   - ç‰¹å¾ï¼šé«˜é¢‘éšæœºå™ªå£°å¢åŠ 
   - è¡¨ç°ï¼šä¿¡å·æ•´ä½“å˜"æ¯›èº"
   - è§£å†³ï¼šæ¸…æ´çš®è‚¤ã€ä½¿ç”¨å¯¼ç”µè†ã€æ›´æ¢ç”µæ

5. **å¿ƒç”µå¹²æ‰°ï¼ˆECG Artifactsï¼‰**
   - æ¥æºï¼šå¿ƒè„çš„ç”µæ´»åŠ¨ï¼ˆé‡‡é›†é è¿‘èƒ¸éƒ¨è‚Œè‚‰æ—¶ï¼‰
   - ç‰¹å¾ï¼šå‘¨æœŸæ€§å°–å³°ï¼ˆå¿ƒç‡é¢‘ç‡ï¼Œçº¦1Hzï¼‰
   - è§£å†³ï¼šç”µæè¿œç¦»å¿ƒè„ã€ä¿¡å·å¤„ç†ç®—æ³•

6. **ä¸²æ‰°ï¼ˆCrosstalkï¼‰**
   - æ¥æºï¼šé‚»è¿‘è‚Œè‚‰çš„ä¿¡å·æ··å…¥
   - ç‰¹å¾ï¼šæ„å¤–çš„è‚Œè‚‰æ´»åŠ¨ä¿¡å·
   - è§£å†³ï¼šç”µææ­£ç¡®æ”¾ç½®ã€å·®åˆ†æ”¾å¤§

**ä¿¡å·è´¨é‡è¯„ä¼°**ï¼š
- **ä¿¡å™ªæ¯”ï¼ˆSNRï¼‰**: ä¿¡å·åŠŸç‡ä¸å™ªå£°åŠŸç‡çš„æ¯”å€¼
  - SNR > 20 dBï¼šè‰¯å¥½
  - SNR < 10 dBï¼šè´¨é‡å·®ï¼Œéœ€è¦æ”¹å–„

**å®è·µä»»åŠ¡**ï¼š
1. è§‚å¯Ÿæä¾›çš„æ ·æœ¬EMGæ•°æ®
2. è¯†åˆ«å¹¶æ ‡æ³¨å‡ºä»¥ä¸‹å†…å®¹ï¼š
   - é™æ¯æ®µ
   - è‚Œè‚‰æ¿€æ´»æ®µ
   - å¯èƒ½çš„å·¥é¢‘å¹²æ‰°
   - è¿åŠ¨ä¼ªå½±
3. ç»˜åˆ¶ä¿¡å·çš„åŠŸç‡è°±ï¼Œè§‚å¯Ÿé¢‘ç‡åˆ†å¸ƒ

**ä½œä¸š**ï¼š
- å®Œæˆ"EMGä¿¡å·ç‰¹å¾è¯†åˆ«"ç»ƒä¹ é¢˜
- ä½¿ç”¨æä¾›çš„Pythonè„šæœ¬ï¼ŒåŠ è½½sampleæ•°æ®å¹¶ç”Ÿæˆæ—¶åŸŸå’Œé¢‘åŸŸå›¾
- å†™ä¸€æ®µè¯æè¿°ä½ çœ‹åˆ°çš„ä¿¡å·ç‰¹å¾

---

### ç¬¬3å‘¨å­¦ä¹ æ£€æŸ¥ç‚¹
âœ… èƒ½è¯†åˆ«EMGä¿¡å·çš„é™æ¯å’Œæ¿€æ´»çŠ¶æ€
âœ… ç†è§£æ—¶åŸŸå’Œé¢‘åŸŸçš„æ¦‚å¿µ
âœ… èƒ½è¯´å‡ºEMGçš„ä¸»è¦é¢‘ç‡èŒƒå›´
âœ… èƒ½è¯†åˆ«è‡³å°‘3ç§å¸¸è§å™ªå£°
âœ… çŸ¥é“SNRçš„å«ä¹‰å’Œé‡è¦æ€§

---

## ğŸ’» ç¬¬ä¸‰é˜¶æ®µï¼šPythonåŸºç¡€å’Œæ•°æ®å¤„ç†ï¼ˆç¬¬4-5å‘¨ï¼‰

### å­¦ä¹ ç›®æ ‡
- æŒæ¡Pythonç¼–ç¨‹çš„åŸºç¡€è¯­æ³•
- å­¦ä¼šä½¿ç”¨ç§‘å­¦è®¡ç®—åº“å¤„ç†æ•°æ®
- èƒ½å¤Ÿè¯»å–ã€å¤„ç†å’Œå¯è§†åŒ–EMGæ•°æ®

### 3.1 Pythonç¯å¢ƒæ­å»º

**å®‰è£…Anaconda**ï¼š
1. ä¸‹è½½Anacondaï¼ˆPython 3.9æˆ–3.10ç‰ˆæœ¬ï¼‰
2. å®‰è£…å¹¶éªŒè¯ï¼šæ‰“å¼€ç»ˆç«¯/å‘½ä»¤æç¤ºç¬¦ï¼Œè¾“å…¥`python --version`
3. åˆ›å»ºä¸“ç”¨ç¯å¢ƒï¼š
```bash
conda create -n emg_env python=3.9
conda activate emg_env
```

**å®‰è£…å¿…è¦çš„åº“**ï¼š
```bash
pip install numpy pandas matplotlib scipy scikit-learn
pip install pyqtgraph pyserial  # åç»­å®æ—¶ç³»ç»Ÿä½¿ç”¨
```

**æµ‹è¯•å®‰è£…**ï¼š
```python
import numpy as np
import matplotlib.pyplot as plt
print("ç¯å¢ƒé…ç½®æˆåŠŸï¼")
```

---

### 3.2 PythonåŸºç¡€è¯­æ³•ï¼ˆå¿«é€Ÿå…¥é—¨ï¼‰

**å˜é‡å’Œæ•°æ®ç±»å‹**ï¼š
```python
# æ•°å­—
age = 17
height = 1.75
is_student = True

# å­—ç¬¦ä¸²
name = "EMG Project"
print(f"æˆ‘çš„é¡¹ç›®æ˜¯: {name}")

# åˆ—è¡¨ï¼ˆæ•°ç»„ï¼‰
channels = [1, 2, 3, 4]
emg_values = [0.5, 1.2, 0.8, 1.5]
```

**å¾ªç¯å’Œæ¡ä»¶**ï¼š
```python
# forå¾ªç¯
for i in range(5):
    print(f"ç¬¬{i}æ¬¡è¿­ä»£")

# æ¡ä»¶åˆ¤æ–­
threshold = 1.0
if emg_values[0] > threshold:
    print("è‚Œè‚‰æ¿€æ´»")
else:
    print("è‚Œè‚‰é™æ¯")
```

**å‡½æ•°å®šä¹‰**ï¼š
```python
def calculate_mean(data):
    """è®¡ç®—å¹³å‡å€¼"""
    total = sum(data)
    return total / len(data)

result = calculate_mean([1, 2, 3, 4, 5])
print(f"å¹³å‡å€¼: {result}")
```

---

### 3.3 NumPyæ•°ç»„æ“ä½œ

**åˆ›å»ºæ•°ç»„**ï¼š
```python
import numpy as np

# ä»åˆ—è¡¨åˆ›å»º
arr = np.array([1, 2, 3, 4, 5])

# åˆ›å»ºç‰¹å®šæ•°ç»„
zeros = np.zeros(100)        # 100ä¸ª0
ones = np.ones(50)           # 50ä¸ª1
arange = np.arange(0, 10, 0.1)  # 0åˆ°10ï¼Œæ­¥é•¿0.1
linspace = np.linspace(0, 1, 1000)  # 0åˆ°1å‡åŒ€åˆ†å¸ƒ1000ä¸ªç‚¹
```

**æ•°ç»„è¿ç®—**ï¼š
```python
# æ•°ç»„è¿ç®—ï¼ˆé€å…ƒç´ ï¼‰
arr = np.array([1, 2, 3, 4])
print(arr + 10)      # [11 12 13 14]
print(arr * 2)       # [2 4 6 8]
print(arr ** 2)      # [1 4 9 16]

# ç»Ÿè®¡å‡½æ•°
data = np.random.randn(1000)  # 1000ä¸ªéšæœºæ•°
print(f"å‡å€¼: {data.mean()}")
print(f"æ ‡å‡†å·®: {data.std()}")
print(f"æœ€å¤§å€¼: {data.max()}")
print(f"æœ€å°å€¼: {data.min()}")
```

**æ•°ç»„ç´¢å¼•å’Œåˆ‡ç‰‡**ï¼š
```python
signal = np.arange(0, 100)

# ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰
first = signal[0]        # ç¬¬ä¸€ä¸ªå…ƒç´ 
last = signal[-1]        # æœ€åä¸€ä¸ªå…ƒç´ 

# åˆ‡ç‰‡
first_10 = signal[0:10]  # å‰10ä¸ª
middle = signal[40:60]   # ä¸­é—´20ä¸ª
every_5th = signal[::5]  # æ¯éš”5ä¸ªå–ä¸€ä¸ª
```

**å¸ƒå°”ç´¢å¼•**ï¼š
```python
emg = np.random.randn(100)
threshold = 0.5

# æ‰¾å‡ºæ‰€æœ‰å¤§äºé˜ˆå€¼çš„å€¼
activated = emg[emg > threshold]
print(f"æ¿€æ´»æ ·æœ¬æ•°: {len(activated)}")
```

---

### 3.4 Matplotlibæ•°æ®å¯è§†åŒ–

**åŸºç¡€ç»˜å›¾**ï¼š
```python
import matplotlib.pyplot as plt

# ç®€å•æŠ˜çº¿å›¾
x = np.linspace(0, 10, 100)
y = np.sin(x)

plt.plot(x, y)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Sine Wave')
plt.grid(True)
plt.show()
```

**å¤šå­å›¾**ï¼š
```python
fig, axes = plt.subplots(2, 1, figsize=(10, 6))

# ç¬¬ä¸€ä¸ªå­å›¾
axes[0].plot(x, np.sin(x), 'b-', label='sin(x)')
axes[0].set_ylabel('Sine')
axes[0].legend()
axes[0].grid(True)

# ç¬¬äºŒä¸ªå­å›¾
axes[1].plot(x, np.cos(x), 'r-', label='cos(x)')
axes[1].set_ylabel('Cosine')
axes[1].set_xlabel('Time')
axes[1].legend()
axes[1].grid(True)

plt.tight_layout()
plt.show()
```

**æ ·å¼å®šåˆ¶**ï¼š
```python
plt.figure(figsize=(12, 4))
plt.plot(x, y,
         color='blue',          # é¢œè‰²
         linewidth=2,           # çº¿å®½
         linestyle='-',         # çº¿å‹: '-', '--', '-.', ':'
         marker='o',            # æ ‡è®°: 'o', 's', '^', 'x'
         markersize=4,          # æ ‡è®°å¤§å°
         alpha=0.7)             # é€æ˜åº¦
plt.show()
```

---

### 3.5 Pandasæ•°æ®ç®¡ç†

**è¯»å–CSVæ–‡ä»¶**ï¼š
```python
import pandas as pd

# è¯»å–EMGæ•°æ®
data = pd.read_csv('emg_data.csv')

# æŸ¥çœ‹æ•°æ®
print(data.head())        # å‰5è¡Œ
print(data.info())        # æ•°æ®ä¿¡æ¯
print(data.describe())    # ç»Ÿè®¡æ‘˜è¦
```

**æ•°æ®é€‰æ‹©**ï¼š
```python
# é€‰æ‹©åˆ—
channel_0 = data['channel_0']
multiple = data[['channel_0', 'channel_1']]

# é€‰æ‹©è¡Œ
first_100 = data.iloc[0:100]    # æŒ‰ä½ç½®
time_range = data[data['time'] < 5.0]  # æŒ‰æ¡ä»¶
```

**æ•°æ®å¤„ç†**ï¼š
```python
# æ·»åŠ æ–°åˆ—
data['channel_0_squared'] = data['channel_0'] ** 2

# åˆ†ç»„ç»Ÿè®¡
by_label = data.groupby('label')['channel_0'].mean()

# ä¿å­˜ç»“æœ
data.to_csv('processed_emg.csv', index=False)
```

---

### 3.6 ç»¼åˆå®è·µï¼šEMGæ•°æ®åŠ è½½å’Œå¯è§†åŒ–

**å®Œæ•´ç¤ºä¾‹**ï¼š
```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 1. è¯»å–æ•°æ®
data = pd.read_csv('sample_emg.csv')
print(f"æ•°æ®å½¢çŠ¶: {data.shape}")
print(f"åˆ—å: {data.columns.tolist()}")

# 2. æå–ä¿¡å·
fs = 1000  # é‡‡æ ·ç‡
channels = ['channel_0', 'channel_1', 'channel_2', 'channel_3']
num_channels = len(channels)

# 3. åˆ›å»ºæ—¶é—´è½´
num_samples = len(data)
time = np.arange(num_samples) / fs

# 4. å¯è§†åŒ–å¤šé€šé“ä¿¡å·
fig, axes = plt.subplots(num_channels, 1, figsize=(14, 8))
fig.suptitle('Multi-Channel EMG Signals', fontsize=16)

for i, (ax, ch) in enumerate(zip(axes, channels)):
    signal = data[ch].values
    ax.plot(time, signal, linewidth=0.5)
    ax.set_ylabel(f'Ch{i}\n(mV)')
    ax.grid(True, alpha=0.3)

    # åªåœ¨æœ€åä¸€ä¸ªå­å›¾æ˜¾ç¤ºxè½´æ ‡ç­¾
    if i < num_channels - 1:
        ax.set_xticks([])
    else:
        ax.set_xlabel('Time (s)')

plt.tight_layout()
plt.savefig('multi_channel_emg.png', dpi=150)
plt.show()

# 5. ç»Ÿè®¡åˆ†æ
print("\nä¿¡å·ç»Ÿè®¡ä¿¡æ¯:")
for ch in channels:
    signal = data[ch].values
    print(f"{ch}:")
    print(f"  å‡å€¼: {signal.mean():.6f} mV")
    print(f"  æ ‡å‡†å·®: {signal.std():.6f} mV")
    print(f"  æœ€å¤§å€¼: {signal.max():.6f} mV")
    print(f"  æœ€å°å€¼: {signal.min():.6f} mV")
```

---

### ç¬¬4-5å‘¨å®è·µä½œä¸š

**ä½œä¸š1ï¼šåŸºç¡€Pythonç»ƒä¹ **
1. ç¼–å†™å‡½æ•°è®¡ç®—åˆ—è¡¨çš„æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ï¼ˆä¸ä½¿ç”¨å†…ç½®å‡½æ•°ï¼‰
2. ç”Ÿæˆä¸€ä¸ª100ä¸ªéšæœºæ•°çš„æ•°ç»„ï¼Œç»Ÿè®¡å¤§äº0.5çš„æ•°é‡

**ä½œä¸š2ï¼šæ•°ç»„æ“ä½œ**
1. åˆ›å»ºä¸€ä¸ª1000ç‚¹çš„æ¨¡æ‹ŸEMGä¿¡å·ï¼ˆéšæœºå™ªå£°+æ­£å¼¦æ³¢ï¼‰
2. å¯¹ä¿¡å·è¿›è¡Œå½’ä¸€åŒ–å¤„ç†ï¼ˆèŒƒå›´è°ƒæ•´åˆ°[-1, 1]ï¼‰
3. æå–ä¿¡å·çš„å‰10ç§’æ•°æ®

**ä½œä¸š3ï¼šæ•°æ®å¯è§†åŒ–**
1. è¯»å–æä¾›çš„æ ·æœ¬EMGæ•°æ®
2. ç»˜åˆ¶4é€šé“ä¿¡å·çš„æ—¶åŸŸå›¾
3. ä¸ºæ¯ä¸ªé€šé“æ·»åŠ æ ‡é¢˜ã€åæ ‡è½´æ ‡ç­¾ã€ç½‘æ ¼
4. ä¿å­˜å›¾ç‰‡ä¸ºPNGæ ¼å¼

**ä½œä¸š4ï¼šç»¼åˆç»ƒä¹ **
ç¼–å†™ä¸€ä¸ªå®Œæ•´è„šæœ¬ï¼Œå®ç°ï¼š
- è¯»å–CSVæ ¼å¼çš„EMGæ•°æ®
- è®¡ç®—æ¯ä¸ªé€šé“çš„RMSå€¼
- ç»˜åˆ¶RMSå€¼çš„æŸ±çŠ¶å›¾
- æ‰¾å‡ºRMSæœ€å¤§çš„é€šé“ï¼ˆæœ€æ´»è·ƒçš„è‚Œè‚‰ï¼‰

---

### ç¬¬4-5å‘¨å­¦ä¹ æ£€æŸ¥ç‚¹
âœ… èƒ½ç‹¬ç«‹å®‰è£…å’Œé…ç½®Pythonç¯å¢ƒ
âœ… æŒæ¡å˜é‡ã€åˆ—è¡¨ã€å¾ªç¯ã€å‡½æ•°ç­‰åŸºç¡€è¯­æ³•
âœ… èƒ½ä½¿ç”¨NumPyè¿›è¡Œæ•°ç»„æ“ä½œå’Œæ•°å­¦è¿ç®—
âœ… èƒ½ä½¿ç”¨Matplotlibç»˜åˆ¶æ¸…æ™°çš„æ•°æ®å›¾è¡¨
âœ… èƒ½è¯»å–CSVæ–‡ä»¶å¹¶æå–æ‰€éœ€æ•°æ®
âœ… èƒ½ç¼–å†™å®Œæ•´è„šæœ¬å¤„ç†å’Œå¯è§†åŒ–EMGæ•°æ®

---

## ğŸ›ï¸ ç¬¬å››é˜¶æ®µï¼šä¿¡å·é¢„å¤„ç†ï¼ˆç¬¬6å‘¨ï¼‰

### å­¦ä¹ ç›®æ ‡
- ç†è§£æ»¤æ³¢å™¨çš„åŸç†å’Œä½œç”¨
- å®ç°EMGä¿¡å·çš„æ»¤æ³¢å¤„ç†
- è¯„ä¼°ä¿¡å·è´¨é‡

### 4.1 ä¸ºä»€ä¹ˆéœ€è¦é¢„å¤„ç†ï¼Ÿ

**åŸå§‹EMGä¿¡å·çš„é—®é¢˜**ï¼š
- åŒ…å«å¤§é‡å™ªå£°å’Œå¹²æ‰°
- å·¥é¢‘å¹²æ‰°ï¼ˆ50/60Hzï¼‰æ©ç›–çœŸå®ä¿¡å·
- åŸºçº¿æ¼‚ç§»å½±å“å¹…åº¦æµ‹é‡
- é«˜é¢‘å™ªå£°ä½¿ä¿¡å·"æ¯›èº"

**é¢„å¤„ç†çš„ç›®æ ‡**ï¼š
- å»é™¤å™ªå£°ï¼Œä¿ç•™æœ‰ç”¨ä¿¡å·
- æé«˜ä¿¡å·è´¨é‡ï¼ˆSNRï¼‰
- ä¸ºåç»­ç‰¹å¾æå–åšå‡†å¤‡

---

### 4.2 æ»¤æ³¢å™¨åŸºç¡€

**ä»€ä¹ˆæ˜¯æ»¤æ³¢å™¨ï¼Ÿ**
- æ»¤æ³¢å™¨æ˜¯ä¸€ç§æ•°å­¦å·¥å…·ï¼Œç”¨äº"ç­›é€‰"ç‰¹å®šé¢‘ç‡çš„ä¿¡å·
- å…è®¸æŸäº›é¢‘ç‡é€šè¿‡ï¼Œé˜»æ­¢å…¶ä»–é¢‘ç‡

**æ»¤æ³¢å™¨ç±»å‹**ï¼š

1. **ä½é€šæ»¤æ³¢å™¨ï¼ˆLow-Pass Filter, LPFï¼‰**
   - å…è®¸ä½é¢‘é€šè¿‡ï¼Œé˜»æ­¢é«˜é¢‘
   - ç”¨é€”ï¼šå»é™¤é«˜é¢‘å™ªå£°
   - EMGåº”ç”¨ï¼šæˆªæ­¢é¢‘ç‡500Hz

2. **é«˜é€šæ»¤æ³¢å™¨ï¼ˆHigh-Pass Filter, HPFï¼‰**
   - å…è®¸é«˜é¢‘é€šè¿‡ï¼Œé˜»æ­¢ä½é¢‘
   - ç”¨é€”ï¼šå»é™¤åŸºçº¿æ¼‚ç§»ã€è¿åŠ¨ä¼ªå½±
   - EMGåº”ç”¨ï¼šæˆªæ­¢é¢‘ç‡20Hz

3. **å¸¦é€šæ»¤æ³¢å™¨ï¼ˆBand-Pass Filter, BPFï¼‰**
   - åªå…è®¸ç‰¹å®šé¢‘ç‡èŒƒå›´é€šè¿‡
   - ç›¸å½“äºé«˜é€š+ä½é€š
   - EMGåº”ç”¨ï¼š20-500Hz

4. **é™·æ³¢æ»¤æ³¢å™¨ï¼ˆNotch Filterï¼‰**
   - é˜»æ­¢ç‰¹å®šé¢‘ç‡ï¼ˆåŠå…¶é™„è¿‘ï¼‰
   - ç”¨é€”ï¼šå»é™¤å·¥é¢‘å¹²æ‰°
   - EMGåº”ç”¨ï¼š50Hzæˆ–60Hz

**æ»¤æ³¢å™¨å‚æ•°**ï¼š
- **æˆªæ­¢é¢‘ç‡ï¼ˆCutoff Frequencyï¼‰**: æ»¤æ³¢å™¨å¼€å§‹è¡°å‡çš„é¢‘ç‡
- **é˜¶æ•°ï¼ˆOrderï¼‰**: æ»¤æ³¢å™¨çš„"é”åˆ©åº¦"ï¼Œé˜¶æ•°è¶Šé«˜ï¼Œè¿‡æ¸¡è¶Šé™¡å³­
- **Qå› å­**: é™·æ³¢æ»¤æ³¢å™¨çš„å¸¦å®½ï¼ŒQè¶Šå¤§ï¼Œå¸¦å®½è¶Šçª„

---

### 4.3 EMGä¿¡å·æ»¤æ³¢å®ç°

**å¸¦é€šæ»¤æ³¢å™¨å®ç°**ï¼š
```python
from scipy.signal import butter, filtfilt
import numpy as np
import matplotlib.pyplot as plt

def bandpass_filter(signal, lowcut=20, highcut=500, fs=1000, order=4):
    """
    å¸¦é€šæ»¤æ³¢å™¨

    å‚æ•°:
        signal: è¾“å…¥ä¿¡å·
        lowcut: é«˜é€šæˆªæ­¢é¢‘ç‡ï¼ˆHzï¼‰
        highcut: ä½é€šæˆªæ­¢é¢‘ç‡ï¼ˆHzï¼‰
        fs: é‡‡æ ·ç‡ï¼ˆHzï¼‰
        order: æ»¤æ³¢å™¨é˜¶æ•°

    è¿”å›:
        filtered_signal: æ»¤æ³¢åçš„ä¿¡å·
    """
    # è®¡ç®—å½’ä¸€åŒ–é¢‘ç‡
    nyquist = 0.5 * fs  # å¥ˆå¥æ–¯ç‰¹é¢‘ç‡
    low = lowcut / nyquist
    high = highcut / nyquist

    # è®¾è®¡Butterworthæ»¤æ³¢å™¨
    b, a = butter(order, [low, high], btype='band')

    # åº”ç”¨é›¶ç›¸ä½æ»¤æ³¢
    filtered_signal = filtfilt(b, a, signal)

    return filtered_signal

# ç¤ºä¾‹ä½¿ç”¨
# å‡è®¾signalæ˜¯ä½ çš„EMGä¿¡å·ï¼Œfs=1000Hz
filtered = bandpass_filter(signal, lowcut=20, highcut=500, fs=1000, order=4)
```

**é™·æ³¢æ»¤æ³¢å™¨å®ç°**ï¼š
```python
from scipy.signal import iirnotch

def notch_filter(signal, freq=50, fs=1000, Q=30):
    """
    é™·æ³¢æ»¤æ³¢å™¨ï¼ˆå»é™¤å·¥é¢‘å¹²æ‰°ï¼‰

    å‚æ•°:
        signal: è¾“å…¥ä¿¡å·
        freq: è¦å»é™¤çš„é¢‘ç‡ï¼ˆHzï¼‰
        fs: é‡‡æ ·ç‡ï¼ˆHzï¼‰
        Q: å“è´¨å› å­ï¼Œè¶Šå¤§å¸¦å®½è¶Šçª„

    è¿”å›:
        filtered_signal: æ»¤æ³¢åçš„ä¿¡å·
    """
    # è®¾è®¡é™·æ³¢æ»¤æ³¢å™¨
    b, a = iirnotch(freq, Q, fs)

    # åº”ç”¨æ»¤æ³¢
    filtered_signal = filtfilt(b, a, signal)

    return filtered_signal

# å»é™¤50Hzå·¥é¢‘å¹²æ‰°
filtered = notch_filter(signal, freq=50, fs=1000, Q=30)
```

**å®Œæ•´çš„EMGé¢„å¤„ç†æµç¨‹**ï¼š
```python
def preprocess_emg(signal, fs=1000):
    """
    EMGä¿¡å·å®Œæ•´é¢„å¤„ç†æµç¨‹
    """
    # 1. å¸¦é€šæ»¤æ³¢ï¼ˆ20-500Hzï¼‰
    signal_bp = bandpass_filter(signal, lowcut=20, highcut=500, fs=fs)

    # 2. é™·æ³¢æ»¤æ³¢ï¼ˆå»é™¤å·¥é¢‘å¹²æ‰°ï¼‰
    signal_notch = notch_filter(signal_bp, freq=50, fs=fs)

    # 3. å½’ä¸€åŒ–ï¼ˆå¯é€‰ï¼‰
    signal_normalized = (signal_notch - signal_notch.mean()) / signal_notch.std()

    return signal_normalized

# ä½¿ç”¨
processed_signal = preprocess_emg(raw_signal, fs=1000)
```

---

### 4.4 æ»¤æ³¢æ•ˆæœå¯è§†åŒ–

**å¯¹æ¯”åŸå§‹ä¿¡å·å’Œæ»¤æ³¢ä¿¡å·**ï¼š
```python
def compare_filtering(signal, fs=1000):
    """å¯¹æ¯”æ»¤æ³¢å‰åçš„ä¿¡å·"""

    # é¢„å¤„ç†
    filtered = preprocess_emg(signal, fs)

    # æ—¶åŸŸå¯¹æ¯”
    fig, axes = plt.subplots(3, 1, figsize=(14, 10))
    time = np.arange(len(signal)) / fs

    # æ˜¾ç¤ºå‰2ç§’
    n_samples = int(2 * fs)
    t = time[:n_samples]

    # åŸå§‹ä¿¡å·
    axes[0].plot(t, signal[:n_samples], linewidth=0.5)
    axes[0].set_ylabel('åŸå§‹ä¿¡å· (mV)')
    axes[0].set_title('æ»¤æ³¢å‰åå¯¹æ¯”')
    axes[0].grid(True)

    # æ»¤æ³¢åä¿¡å·
    axes[1].plot(t, filtered[:n_samples], linewidth=0.5, color='orange')
    axes[1].set_ylabel('æ»¤æ³¢å (mV)')
    axes[1].grid(True)

    # é¢‘åŸŸå¯¹æ¯”
    from scipy.fft import fft, fftfreq

    N = len(signal)
    freqs = fftfreq(N, 1/fs)[:N//2]

    # åŸå§‹ä¿¡å·é¢‘è°±
    fft_raw = np.abs(fft(signal))[:N//2]
    fft_filtered = np.abs(fft(filtered))[:N//2]

    axes[2].semilogy(freqs, fft_raw, label='åŸå§‹', alpha=0.7)
    axes[2].semilogy(freqs, fft_filtered, label='æ»¤æ³¢å', alpha=0.7)
    axes[2].set_xlabel('é¢‘ç‡ (Hz)')
    axes[2].set_ylabel('å¹…åº¦')
    axes[2].set_xlim(0, 300)
    axes[2].legend()
    axes[2].grid(True)

    plt.tight_layout()
    plt.savefig('filtering_comparison.png', dpi=150)
    plt.show()

# ä½¿ç”¨
compare_filtering(raw_emg_signal, fs=1000)
```

---

### 4.5 ä¿¡å·è´¨é‡è¯„ä¼°

**ä¿¡å™ªæ¯”ï¼ˆSNRï¼‰è®¡ç®—**ï¼š
```python
def calculate_snr(signal):
    """
    è®¡ç®—ä¿¡å·å™ªå£°æ¯”

    ç®€åŒ–æ–¹æ³•ï¼šå‡è®¾ä¿¡å·åŠŸç‡æ˜¯æœ‰ç”¨ä¿¡å·ï¼Œå™ªå£°åŠŸç‡æ˜¯æ³¢åŠ¨
    """
    # ä¿¡å·åŠŸç‡ï¼ˆä½¿ç”¨RMSï¼‰
    signal_power = np.mean(signal ** 2)

    # å™ªå£°åŠŸç‡ï¼ˆä½¿ç”¨é«˜é¢‘æˆåˆ†æˆ–æ®‹å·®æ–¹å·®ï¼‰
    # æ–¹æ³•1ï¼šä½¿ç”¨ä¿¡å·ä¸å…¶å‡å€¼çš„åå·®
    noise_power = np.var(signal - np.mean(signal))

    # è®¡ç®—SNRï¼ˆdBï¼‰
    if noise_power > 0:
        snr_db = 10 * np.log10(signal_power / noise_power)
    else:
        snr_db = np.inf

    return snr_db

# å¯¹æ¯”æ»¤æ³¢å‰åçš„SNR
snr_before = calculate_snr(raw_signal)
snr_after = calculate_snr(filtered_signal)

print(f"æ»¤æ³¢å‰ SNR: {snr_before:.2f} dB")
print(f"æ»¤æ³¢å SNR: {snr_after:.2f} dB")
print(f"æ”¹å–„: {snr_after - snr_before:.2f} dB")
```

**åŸºçº¿æ£€æŸ¥**ï¼š
```python
def check_baseline(signal, window_size=100):
    """æ£€æŸ¥ä¿¡å·åŸºçº¿ç¨³å®šæ€§"""

    # æ»‘åŠ¨çª—å£è®¡ç®—å‡å€¼
    baseline = np.convolve(signal, np.ones(window_size)/window_size, mode='valid')

    # åŸºçº¿åç§»é‡
    baseline_drift = np.max(np.abs(baseline))

    plt.figure(figsize=(12, 4))
    plt.plot(signal, label='ä¿¡å·', alpha=0.6)
    plt.plot(baseline, label='åŸºçº¿', linewidth=2, color='red')
    plt.xlabel('æ ·æœ¬')
    plt.ylabel('å¹…åº¦ (mV)')
    plt.title(f'åŸºçº¿æ¼‚ç§»æ£€æŸ¥ (æœ€å¤§æ¼‚ç§»: {baseline_drift:.4f} mV)')
    plt.legend()
    plt.grid(True)
    plt.show()

    return baseline_drift

drift = check_baseline(signal)
```

---

### ç¬¬6å‘¨å®è·µä½œä¸š

**ä½œä¸š1ï¼šæ»¤æ³¢å™¨å®ç°**
1. å®ç°ä¸€ä¸ªé«˜é€šæ»¤æ³¢å™¨ï¼ˆ20Hzï¼‰
2. å®ç°ä¸€ä¸ªä½é€šæ»¤æ³¢å™¨ï¼ˆ500Hzï¼‰
3. å¯¹æ¯”å®ƒä»¬ä¸å¸¦é€šæ»¤æ³¢å™¨çš„æ•ˆæœ

**ä½œä¸š2ï¼šå·¥é¢‘å¹²æ‰°å»é™¤**
1. åŠ è½½å«æœ‰50Hzå¹²æ‰°çš„EMGæ•°æ®
2. ä½¿ç”¨é™·æ³¢æ»¤æ³¢å™¨å»é™¤å¹²æ‰°
3. ç»˜åˆ¶æ»¤æ³¢å‰åçš„é¢‘è°±å›¾ï¼ŒéªŒè¯50Hzå³°å€¼æ¶ˆå¤±

**ä½œä¸š3ï¼šå‚æ•°è°ƒä¼˜**
1. å°è¯•ä¸åŒçš„æ»¤æ³¢å™¨é˜¶æ•°ï¼ˆ2, 4, 6, 8ï¼‰
2. è§‚å¯Ÿé˜¶æ•°å¯¹æ»¤æ³¢æ•ˆæœçš„å½±å“
3. ç»˜åˆ¶å¯¹æ¯”å›¾ï¼Œé€‰æ‹©æœ€ä½³é˜¶æ•°

**ä½œä¸š4ï¼šå®Œæ•´é¢„å¤„ç†æµç¨‹**
1. ç¼–å†™ä¸€ä¸ªæ‰¹å¤„ç†è„šæœ¬ï¼Œå¯¹å¤šä¸ªEMGæ–‡ä»¶è¿›è¡Œé¢„å¤„ç†
2. ä¿å­˜æ»¤æ³¢åçš„ä¿¡å·åˆ°æ–°æ–‡ä»¶
3. ç”Ÿæˆå¤„ç†æŠ¥å‘Šï¼ˆåŒ…æ‹¬SNRæ”¹å–„ã€åŸºçº¿æ£€æŸ¥ç­‰ï¼‰

---

### ç¬¬6å‘¨å­¦ä¹ æ£€æŸ¥ç‚¹
âœ… ç†è§£æ»¤æ³¢å™¨çš„åŸºæœ¬åŸç†å’Œç±»å‹
âœ… èƒ½å®ç°å¸¦é€šã€é™·æ³¢æ»¤æ³¢å™¨
âœ… èƒ½å¯è§†åŒ–æ»¤æ³¢å‰åçš„å¯¹æ¯”
âœ… èƒ½è®¡ç®—å’Œè§£é‡ŠSNR
âœ… èƒ½è¯„ä¼°ä¿¡å·é¢„å¤„ç†çš„è´¨é‡

---

## ğŸ“Š ç¬¬äº”é˜¶æ®µï¼šç‰¹å¾æå–ï¼ˆç¬¬7å‘¨ï¼‰

### å­¦ä¹ ç›®æ ‡
- ç†è§£ç‰¹å¾æå–çš„æ„ä¹‰
- å®ç°æ—¶åŸŸå’Œé¢‘åŸŸç‰¹å¾æå–
- ä½¿ç”¨æ»‘åŠ¨çª—å£è¿›è¡Œç‰¹å¾è®¡ç®—

### 5.1 ä¸ºä»€ä¹ˆéœ€è¦ç‰¹å¾æå–ï¼Ÿ

**åŸå§‹ä¿¡å· vs ç‰¹å¾**ï¼š
- åŸå§‹ä¿¡å·ï¼š1ç§’é’Ÿæœ‰1000ä¸ªæ•°æ®ç‚¹ï¼ˆé‡‡æ ·ç‡1000Hzï¼‰
- ç‰¹å¾ï¼šç”¨å‡ ä¸ªæ•°å€¼æ¦‚æ‹¬ä¿¡å·çš„ç‰¹æ€§

**ç‰¹å¾æå–çš„å¥½å¤„**ï¼š
1. **é™ç»´**: æ•°æ®é‡å¤§å¹…å‡å°‘
2. **å»å™ª**: ç‰¹å¾å¯¹å™ªå£°æ›´é²æ£’
3. **å¯è§£é‡Š**: ç‰¹å¾æœ‰æ˜ç¡®ç‰©ç†æ„ä¹‰
4. **æœºå™¨å­¦ä¹ **: åˆ†ç±»å™¨çš„è¾“å…¥

**å¸¸ç”¨ç‰¹å¾ç±»å‹**ï¼š
- **æ—¶åŸŸç‰¹å¾**: ä»ä¿¡å·æ³¢å½¢ç›´æ¥è®¡ç®—
- **é¢‘åŸŸç‰¹å¾**: ä»é¢‘è°±è®¡ç®—
- **æ—¶é¢‘ç‰¹å¾**: ç»“åˆæ—¶é—´å’Œé¢‘ç‡ä¿¡æ¯

---

### 5.2 æ—¶åŸŸç‰¹å¾

**å¸¸ç”¨æ—¶åŸŸç‰¹å¾åŠå…¶å«ä¹‰**ï¼š

1. **MAV (Mean Absolute Value) - å¹³å‡ç»å¯¹å€¼**
   - å…¬å¼ï¼š`MAV = (1/N) * Î£|x[i]|`
   - å«ä¹‰ï¼šä¿¡å·çš„å¹³å‡å¼ºåº¦
   - ç”¨é€”ï¼šè¯„ä¼°è‚Œè‚‰æ¿€æ´»æ°´å¹³

2. **RMS (Root Mean Square) - å‡æ–¹æ ¹**
   - å…¬å¼ï¼š`RMS = sqrt((1/N) * Î£x[i]Â²)`
   - å«ä¹‰ï¼šä¿¡å·çš„"æœ‰æ•ˆå€¼"
   - ç”¨é€”ï¼šè‚Œè‚‰åŠ›é‡ä¼°è®¡

3. **VAR (Variance) - æ–¹å·®**
   - å…¬å¼ï¼š`VAR = (1/N) * Î£(x[i] - mean)Â²`
   - å«ä¹‰ï¼šä¿¡å·çš„å˜åŒ–ç¨‹åº¦
   - ç”¨é€”ï¼šä¿¡å·æ´»è·ƒåº¦

4. **WL (Waveform Length) - æ³¢å½¢é•¿åº¦**
   - å…¬å¼ï¼š`WL = Î£|x[i+1] - x[i]|`
   - å«ä¹‰ï¼šä¿¡å·çš„å¤æ‚åº¦
   - ç”¨é€”ï¼šè‚Œè‚‰æ¿€æ´»æ¨¡å¼è¯†åˆ«

5. **ZC (Zero Crossing) - è¿‡é›¶ç‡**
   - å…¬å¼ï¼š`ZC = count(sign(x[i]) != sign(x[i+1]))`
   - å«ä¹‰ï¼šä¿¡å·ç©¿è¿‡é›¶ç‚¹çš„æ¬¡æ•°
   - ç”¨é€”ï¼šé¢‘ç‡ä¿¡æ¯çš„æ—¶åŸŸè¡¨ç¤º

6. **SSC (Slope Sign Change) - æ–œç‡ç¬¦å·å˜åŒ–**
   - å…¬å¼ï¼š`SSC = count((x[i]-x[i-1])*(x[i]-x[i+1]) > 0)`
   - å«ä¹‰ï¼šæ³¢å½¢è½¬æŠ˜ç‚¹æ•°é‡
   - ç”¨é€”ï¼šä¿¡å·é¢‘ç‡ç‰¹å¾

**å®ç°æ—¶åŸŸç‰¹å¾æå–**ï¼š
```python
import numpy as np

def extract_time_features(signal):
    """
    æå–EMGä¿¡å·çš„æ—¶åŸŸç‰¹å¾

    å‚æ•°:
        signal: ä¸€ç»´numpyæ•°ç»„

    è¿”å›:
        features: å­—å…¸ï¼ŒåŒ…å«å„ç§ç‰¹å¾å€¼
    """
    N = len(signal)

    # 1. MAV - å¹³å‡ç»å¯¹å€¼
    mav = np.mean(np.abs(signal))

    # 2. RMS - å‡æ–¹æ ¹
    rms = np.sqrt(np.mean(signal ** 2))

    # 3. VAR - æ–¹å·®
    var = np.var(signal)

    # 4. WL - æ³¢å½¢é•¿åº¦
    wl = np.sum(np.abs(np.diff(signal)))

    # 5. ZC - è¿‡é›¶ç‡ï¼ˆå¸¦é˜ˆå€¼å»é™¤å™ªå£°å½±å“ï¼‰
    threshold = 0.01
    zc = 0
    for i in range(len(signal) - 1):
        if ((signal[i] > threshold and signal[i+1] < -threshold) or
            (signal[i] < -threshold and signal[i+1] > threshold)):
            zc += 1

    # 6. SSC - æ–œç‡ç¬¦å·å˜åŒ–
    ssc = 0
    for i in range(1, len(signal) - 1):
        if ((signal[i] - signal[i-1]) * (signal[i] - signal[i+1]) > threshold):
            ssc += 1

    # 7. IEMG - ç§¯åˆ†EMG
    iemg = np.sum(np.abs(signal))

    # 8. DASDV - æ ‡å‡†å·®çš„å¯¹æ•°
    dasdv = np.sqrt(np.mean((signal - np.mean(signal)) ** 2))

    features = {
        'MAV': mav,
        'RMS': rms,
        'VAR': var,
        'WL': wl,
        'ZC': zc,
        'SSC': ssc,
        'IEMG': iemg,
        'DASDV': dasdv
    }

    return features

# ä½¿ç”¨ç¤ºä¾‹
window = signal[1000:1200]  # 200ä¸ªæ ·æœ¬
features = extract_time_features(window)
print("æ—¶åŸŸç‰¹å¾:")
for name, value in features.items():
    print(f"  {name}: {value:.4f}")
```

---

### 5.3 é¢‘åŸŸç‰¹å¾

**å¸¸ç”¨é¢‘åŸŸç‰¹å¾**ï¼š

1. **MNF (Mean Frequency) - å¹³å‡é¢‘ç‡**
   - åŠŸç‡è°±çš„"é‡å¿ƒ"é¢‘ç‡
   - è‚Œè‚‰ç–²åŠ³æ—¶MNFä¸‹é™

2. **MDF (Median Frequency) - ä¸­å€¼é¢‘ç‡**
   - å°†åŠŸç‡è°±å¹³åˆ†çš„é¢‘ç‡
   - è‚Œè‚‰ç–²åŠ³æŒ‡æ ‡

3. **Peak Frequency - å³°å€¼é¢‘ç‡**
   - åŠŸç‡æœ€å¤§çš„é¢‘ç‡ç‚¹

4. **Total Power - æ€»åŠŸç‡**
   - æ‰€æœ‰é¢‘ç‡æˆåˆ†çš„èƒ½é‡å’Œ

**å®ç°é¢‘åŸŸç‰¹å¾æå–**ï¼š
```python
from scipy.fft import fft, fftfreq

def extract_freq_features(signal, fs=1000):
    """
    æå–EMGä¿¡å·çš„é¢‘åŸŸç‰¹å¾

    å‚æ•°:
        signal: ä¸€ç»´numpyæ•°ç»„
        fs: é‡‡æ ·ç‡ï¼ˆHzï¼‰

    è¿”å›:
        features: å­—å…¸ï¼ŒåŒ…å«é¢‘åŸŸç‰¹å¾
    """
    N = len(signal)

    # è®¡ç®—FFT
    yf = fft(signal)
    xf = fftfreq(N, 1/fs)[:N//2]

    # åŠŸç‡è°±ï¼ˆåªå–æ­£é¢‘ç‡éƒ¨åˆ†ï¼‰
    power = (2.0 / N) * np.abs(yf[:N//2])
    power_squared = power ** 2

    # 1. æ€»åŠŸç‡
    total_power = np.sum(power_squared)

    # 2. å¹³å‡é¢‘ç‡ (MNF)
    if total_power > 0:
        mnf = np.sum(xf * power_squared) / np.sum(power_squared)
    else:
        mnf = 0

    # 3. ä¸­å€¼é¢‘ç‡ (MDF)
    cumsum = np.cumsum(power_squared)
    if cumsum[-1] > 0:
        mdf_idx = np.where(cumsum >= cumsum[-1] / 2)[0]
        mdf = xf[mdf_idx[0]] if len(mdf_idx) > 0 else 0
    else:
        mdf = 0

    # 4. å³°å€¼é¢‘ç‡
    peak_freq = xf[np.argmax(power)]

    # 5. é¢‘è°±çŸ©ï¼ˆç”¨äºè¡¡é‡é¢‘è°±åˆ†æ•£åº¦ï¼‰
    if total_power > 0:
        sm1 = np.sum((xf ** 1) * power_squared) / total_power
        sm2 = np.sum((xf ** 2) * power_squared) / total_power
        sm3 = np.sum((xf ** 3) * power_squared) / total_power
    else:
        sm1 = sm2 = sm3 = 0

    features = {
        'MNF': mnf,
        'MDF': mdf,
        'Peak_Freq': peak_freq,
        'Total_Power': total_power,
        'SM1': sm1,
        'SM2': sm2,
        'SM3': sm3,
        'power_spectrum': power,
        'frequencies': xf
    }

    return features

# ä½¿ç”¨ç¤ºä¾‹
freq_features = extract_freq_features(window, fs=1000)
print("\né¢‘åŸŸç‰¹å¾:")
print(f"  MNF: {freq_features['MNF']:.2f} Hz")
print(f"  MDF: {freq_features['MDF']:.2f} Hz")
print(f"  å³°å€¼é¢‘ç‡: {freq_features['Peak_Freq']:.2f} Hz")
print(f"  æ€»åŠŸç‡: {freq_features['Total_Power']:.4f}")
```

**å¯è§†åŒ–åŠŸç‡è°±**ï¼š
```python
def plot_power_spectrum(signal, fs=1000):
    """ç»˜åˆ¶åŠŸç‡è°±"""
    freq_features = extract_freq_features(signal, fs)

    plt.figure(figsize=(12, 5))

    plt.plot(freq_features['frequencies'],
             freq_features['power_spectrum'],
             linewidth=1)

    # æ ‡æ³¨å…³é”®é¢‘ç‡
    plt.axvline(freq_features['MNF'], color='r',
                linestyle='--', label=f"MNF={freq_features['MNF']:.1f}Hz")
    plt.axvline(freq_features['MDF'], color='g',
                linestyle='--', label=f"MDF={freq_features['MDF']:.1f}Hz")
    plt.axvline(freq_features['Peak_Freq'], color='orange',
                linestyle='--', label=f"Peak={freq_features['Peak_Freq']:.1f}Hz")

    plt.xlabel('é¢‘ç‡ (Hz)')
    plt.ylabel('åŠŸç‡')
    plt.title('EMGåŠŸç‡è°±åŠå…³é”®é¢‘ç‡')
    plt.xlim(0, 300)
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()

plot_power_spectrum(processed_signal, fs=1000)
```

---

### 5.4 æ»‘åŠ¨çª—å£ç‰¹å¾æå–

**ä¸ºä»€ä¹ˆéœ€è¦æ»‘åŠ¨çª—å£ï¼Ÿ**
- EMGä¿¡å·æ˜¯éå¹³ç¨³çš„ï¼Œç‰¹å¾éšæ—¶é—´å˜åŒ–
- æ»‘åŠ¨çª—å£å¯ä»¥æ•æ‰ä¿¡å·çš„åŠ¨æ€å˜åŒ–
- ä¸ºå®æ—¶å¤„ç†æä¾›åŸºç¡€

**çª—å£å‚æ•°**ï¼š
- **çª—å£å¤§å°ï¼ˆWindow Sizeï¼‰**: æ¯ä¸ªçª—å£åŒ…å«å¤šå°‘æ ·æœ¬
  - å¸¸ç”¨ï¼š150-250 msï¼Œå³150-250ä¸ªæ ·æœ¬ï¼ˆfs=1000Hzï¼‰
  - å¤ªå°ï¼šç‰¹å¾ä¸ç¨³å®š
  - å¤ªå¤§ï¼šæ—¶é—´åˆ†è¾¨ç‡ä½

- **æ­¥é•¿ï¼ˆStep/Strideï¼‰**: çª—å£æ¯æ¬¡ç§»åŠ¨å¤šå°‘æ ·æœ¬
  - æ— é‡å ï¼šstep = window_size
  - 50%é‡å ï¼šstep = window_size / 2
  - é‡å å¢åŠ ç‰¹å¾æ•°é‡ï¼Œä½†è®¡ç®—é‡å¢å¤§

**å®ç°æ»‘åŠ¨çª—å£**ï¼š
```python
def sliding_window_features(signal, window_size=200, step=100, fs=1000):
    """
    ä½¿ç”¨æ»‘åŠ¨çª—å£æå–ç‰¹å¾

    å‚æ•°:
        signal: è¾“å…¥ä¿¡å·
        window_size: çª—å£å¤§å°ï¼ˆæ ·æœ¬æ•°ï¼‰
        step: æ­¥é•¿ï¼ˆæ ·æœ¬æ•°ï¼‰
        fs: é‡‡æ ·ç‡

    è¿”å›:
        feature_matrix: ç‰¹å¾çŸ©é˜µï¼Œæ¯è¡Œæ˜¯ä¸€ä¸ªçª—å£çš„ç‰¹å¾
        feature_names: ç‰¹å¾åç§°åˆ—è¡¨
    """
    num_windows = (len(signal) - window_size) // step + 1

    # å­˜å‚¨æ‰€æœ‰çª—å£çš„ç‰¹å¾
    all_features = []

    for i in range(num_windows):
        start = i * step
        end = start + window_size
        window = signal[start:end]

        # æå–æ—¶åŸŸç‰¹å¾
        time_feat = extract_time_features(window)

        # æå–é¢‘åŸŸç‰¹å¾
        freq_feat = extract_freq_features(window, fs)

        # åˆå¹¶ç‰¹å¾ï¼ˆå»é™¤éæ•°å€¼é¡¹ï¼‰
        features = {**time_feat}
        features.update({
            'MNF': freq_feat['MNF'],
            'MDF': freq_feat['MDF'],
            'Peak_Freq': freq_feat['Peak_Freq'],
            'Total_Power': freq_feat['Total_Power']
        })

        all_features.append(features)

    # è½¬æ¢ä¸ºçŸ©é˜µ
    feature_names = list(all_features[0].keys())
    feature_matrix = np.array([[f[name] for name in feature_names]
                               for f in all_features])

    return feature_matrix, feature_names

# ä½¿ç”¨ç¤ºä¾‹
features, names = sliding_window_features(processed_signal,
                                          window_size=200,
                                          step=100,
                                          fs=1000)
print(f"æå–äº† {len(features)} ä¸ªçª—å£çš„ç‰¹å¾")
print(f"æ¯ä¸ªçª—å£æœ‰ {len(names)} ä¸ªç‰¹å¾")
print(f"ç‰¹å¾åç§°: {names}")
```

**å¯è§†åŒ–ç‰¹å¾éšæ—¶é—´çš„å˜åŒ–**ï¼š
```python
def plot_feature_timeline(signal, window_size=200, step=100, fs=1000):
    """å¯è§†åŒ–ç‰¹å¾éšæ—¶é—´çš„å˜åŒ–"""

    features, names = sliding_window_features(signal, window_size, step, fs)

    # åˆ›å»ºæ—¶é—´è½´ï¼ˆæ¯ä¸ªçª—å£çš„ä¸­å¿ƒæ—¶é—´ï¼‰
    window_times = [(i * step + window_size/2) / fs
                    for i in range(len(features))]

    # é€‰æ‹©å‡ ä¸ªå…³é”®ç‰¹å¾ç»˜åˆ¶
    key_features = ['RMS', 'MAV', 'MNF', 'MDF']

    fig, axes = plt.subplots(len(key_features), 1,
                             figsize=(14, 10), sharex=True)
    fig.suptitle('EMGç‰¹å¾éšæ—¶é—´å˜åŒ–', fontsize=16)

    for ax, feat_name in zip(axes, key_features):
        feat_idx = names.index(feat_name)
        feat_values = features[:, feat_idx]

        ax.plot(window_times, feat_values, linewidth=1.5)
        ax.set_ylabel(feat_name)
        ax.grid(True, alpha=0.3)

        # æ ‡æ³¨å¹³å‡å€¼
        mean_val = np.mean(feat_values)
        ax.axhline(mean_val, color='r', linestyle='--',
                   alpha=0.5, label=f'Mean={mean_val:.2f}')
        ax.legend(loc='upper right')

    axes[-1].set_xlabel('æ—¶é—´ (s)')
    plt.tight_layout()
    plt.savefig('feature_timeline.png', dpi=150)
    plt.show()

plot_feature_timeline(processed_signal, window_size=200, step=50, fs=1000)
```

---

### 5.5 ç‰¹å¾å½’ä¸€åŒ–

**ä¸ºä»€ä¹ˆéœ€è¦å½’ä¸€åŒ–ï¼Ÿ**
- ä¸åŒç‰¹å¾çš„é‡çº²å’ŒèŒƒå›´å·®å¼‚å¤§
- æœºå™¨å­¦ä¹ ç®—æ³•å¯¹ç‰¹å¾å°ºåº¦æ•æ„Ÿ
- å½’ä¸€åŒ–æœ‰åŠ©äºç‰¹å¾å…¬å¹³å¯¹æ¯”

**å¸¸ç”¨å½’ä¸€åŒ–æ–¹æ³•**ï¼š

1. **Z-scoreæ ‡å‡†åŒ–**
   - `x_norm = (x - mean) / std`
   - ç»“æœå‡å€¼ä¸º0ï¼Œæ ‡å‡†å·®ä¸º1

2. **Min-Maxå½’ä¸€åŒ–**
   - `x_norm = (x - min) / (max - min)`
   - ç»“æœèŒƒå›´[0, 1]

**å®ç°**ï¼š
```python
from sklearn.preprocessing import StandardScaler, MinMaxScaler

def normalize_features(features, method='zscore'):
    """
    ç‰¹å¾å½’ä¸€åŒ–

    å‚æ•°:
        features: ç‰¹å¾çŸ©é˜µ (n_samples, n_features)
        method: 'zscore' æˆ– 'minmax'

    è¿”å›:
        normalized: å½’ä¸€åŒ–åçš„ç‰¹å¾
        scaler: å½’ä¸€åŒ–å™¨ï¼ˆç”¨äºæ–°æ•°æ®ï¼‰
    """
    if method == 'zscore':
        scaler = StandardScaler()
    elif method == 'minmax':
        scaler = MinMaxScaler()
    else:
        raise ValueError("method must be 'zscore' or 'minmax'")

    normalized = scaler.fit_transform(features)

    return normalized, scaler

# ä½¿ç”¨
normalized_features, scaler = normalize_features(features, method='zscore')

print(f"å½’ä¸€åŒ–å‰: mean={features.mean():.2f}, std={features.std():.2f}")
print(f"å½’ä¸€åŒ–å: mean={normalized_features.mean():.2f}, std={normalized_features.std():.2f}")
```

---

### ç¬¬7å‘¨å®è·µä½œä¸š

**ä½œä¸š1ï¼šç‰¹å¾æå–å®ç°**
1. ç¼–å†™å‡½æ•°æå–æ‰€æœ‰æ—¶åŸŸç‰¹å¾
2. ç¼–å†™å‡½æ•°æå–æ‰€æœ‰é¢‘åŸŸç‰¹å¾
3. å¯¹ä¸€ä¸ª5ç§’çš„EMGä¿¡å·æå–ç‰¹å¾å¹¶æ‰“å°

**ä½œä¸š2ï¼šæ»‘åŠ¨çª—å£**
1. å®ç°æ»‘åŠ¨çª—å£ç‰¹å¾æå–
2. å¯¹æ¯”ä¸åŒçª—å£å¤§å°ï¼ˆ100, 200, 300 samplesï¼‰çš„æ•ˆæœ
3. å¯¹æ¯”ä¸åŒé‡å æ¯”ä¾‹ï¼ˆ0%, 50%, 75%ï¼‰çš„æ•ˆæœ

**ä½œä¸š3ï¼šç‰¹å¾å¯è§†åŒ–**
1. ç»˜åˆ¶RMSéšæ—¶é—´çš„å˜åŒ–æ›²çº¿
2. æ‰¾å‡ºRMSæœ€å¤§çš„3ä¸ªæ—¶é—´æ®µï¼ˆæœ€å¼ºæ¿€æ´»ï¼‰
3. ç»˜åˆ¶è¿™3ä¸ªæ—¶é—´æ®µçš„ä¿¡å·æ³¢å½¢

**ä½œä¸š4ï¼šç‰¹å¾åˆ†æ**
1. é‡‡é›†æˆ–ä½¿ç”¨æ ·æœ¬æ•°æ®ï¼šé™æ¯ã€å¼±æ”¶ç¼©ã€å¼ºæ”¶ç¼©å„3ç»„
2. æå–æ‰€æœ‰ç‰¹å¾
3. å¯¹æ¯”ä¸åŒæ”¶ç¼©å¼ºåº¦ä¸‹å„ç‰¹å¾çš„å˜åŒ–
4. ç»˜åˆ¶æŸ±çŠ¶å›¾å±•ç¤ºå·®å¼‚

**æŒ‘æˆ˜ä½œä¸šï¼šç–²åŠ³æ£€æµ‹**
1. ä½¿ç”¨é•¿æ—¶é—´æŒç»­æ”¶ç¼©çš„æ•°æ®
2. æå–MDFå’ŒMNFéšæ—¶é—´çš„å˜åŒ–
3. è§‚å¯Ÿé¢‘ç‡ç‰¹å¾æ˜¯å¦éšæ—¶é—´ä¸‹é™ï¼ˆç–²åŠ³æ ‡å¿—ï¼‰
4. ç»˜åˆ¶é¢‘ç‡ç‰¹å¾çš„æ—¶é—´åºåˆ—å›¾

---

### ç¬¬7å‘¨å­¦ä¹ æ£€æŸ¥ç‚¹
âœ… ç†è§£ç‰¹å¾æå–çš„ç›®çš„å’Œæ„ä¹‰
âœ… èƒ½å®ç°å¸¸ç”¨çš„æ—¶åŸŸç‰¹å¾æå–
âœ… èƒ½å®ç°å¸¸ç”¨çš„é¢‘åŸŸç‰¹å¾æå–
âœ… èƒ½ä½¿ç”¨æ»‘åŠ¨çª—å£å¤„ç†è¿ç»­ä¿¡å·
âœ… èƒ½å¯è§†åŒ–ç‰¹å¾éšæ—¶é—´çš„å˜åŒ–
âœ… ç†è§£ç‰¹å¾å½’ä¸€åŒ–çš„å¿…è¦æ€§

---

## ğŸ¤– ç¬¬å…­é˜¶æ®µï¼šæ¨¡å¼è¯†åˆ«ï¼ˆç¬¬8å‘¨ï¼‰

### å­¦ä¹ ç›®æ ‡
- ç†è§£æœºå™¨å­¦ä¹ çš„åŸºæœ¬æµç¨‹
- å®ç°EMGæ‰‹åŠ¿åˆ†ç±»
- è¯„ä¼°æ¨¡å‹æ€§èƒ½

### 6.1 æœºå™¨å­¦ä¹ åŸºç¡€

**ä»€ä¹ˆæ˜¯æ¨¡å¼è¯†åˆ«/åˆ†ç±»ï¼Ÿ**
- æ ¹æ®EMGç‰¹å¾è‡ªåŠ¨è¯†åˆ«ç”¨æˆ·çš„æ‰‹åŠ¿æˆ–åŠ¨ä½œ
- è®­ç»ƒæ¨¡å‹å­¦ä¹ "ç‰¹å¾â†’åŠ¨ä½œ"çš„æ˜ å°„å…³ç³»

**æœºå™¨å­¦ä¹ æµç¨‹**ï¼š
```
æ•°æ®é‡‡é›† â†’ é¢„å¤„ç† â†’ ç‰¹å¾æå– â†’ æ¨¡å‹è®­ç»ƒ â†’ æ¨¡å‹è¯„ä¼° â†’ åº”ç”¨éƒ¨ç½²
```

**å¸¸ç”¨åˆ†ç±»ç®—æ³•**ï¼š
1. **Kè¿‘é‚»ï¼ˆKNNï¼‰**: ç®€å•ç›´è§‚ï¼Œä½†é€Ÿåº¦æ…¢
2. **æ”¯æŒå‘é‡æœºï¼ˆSVMï¼‰**: æ•ˆæœå¥½ï¼Œé€‚åˆå°æ•°æ®é›†
3. **éšæœºæ£®æ—ï¼ˆRandom Forestï¼‰**: é²æ£’æ€§å¼ºï¼Œæ˜“ç”¨ï¼ˆæœ¬è¯¾ç¨‹ä¸»è¦ä½¿ç”¨ï¼‰
4. **ç¥ç»ç½‘ç»œ**: å¼ºå¤§ä½†éœ€è¦æ›´å¤šæ•°æ®

---

### 6.2 æ•°æ®å‡†å¤‡

**æ•°æ®é‡‡é›†æ–¹æ¡ˆ**ï¼š
- **æ‰‹åŠ¿ç±»å‹**: æ¡æ‹³ã€å¼ å¼€ã€å·¦è½¬ã€å³è½¬ã€é™æ¯ï¼ˆ5ç±»ï¼‰
- **é‡‡é›†æ¬¡æ•°**: æ¯ä¸ªæ‰‹åŠ¿50-100æ¬¡
- **æ¯æ¬¡æ—¶é•¿**: 3-5ç§’
- **é‡‡é›†å»ºè®®**:
  - ä¿æŒç”µæä½ç½®ä¸€è‡´
  - æ¯ä¸ªåŠ¨ä½œä¹‹é—´ä¼‘æ¯
  - å°è¯•ä¸åŒçš„åŠ›åº¦å’Œé€Ÿåº¦

**æ•°æ®ç»„ç»‡ç»“æ„**ï¼š
```
data/
  gestures/
    fist/
      trial_001.csv
      trial_002.csv
      ...
    open/
      trial_001.csv
      ...
    left/
      ...
    right/
      ...
    rest/
      ...
```

**æ•°æ®åŠ è½½å’Œå¤„ç†**ï¼š
```python
import os
from glob import glob
import pandas as pd
import numpy as np

def load_gesture_dataset(data_folder, window_size=200, step=100, fs=1000):
    """
    åŠ è½½æ‰‹åŠ¿æ•°æ®é›†

    å‚æ•°:
        data_folder: æ•°æ®æ ¹ç›®å½•
        window_size: çª—å£å¤§å°
        step: æ­¥é•¿
        fs: é‡‡æ ·ç‡

    è¿”å›:
        X: ç‰¹å¾çŸ©é˜µ (n_samples, n_features)
        y: æ ‡ç­¾æ•°ç»„ (n_samples,)
        gesture_names: æ‰‹åŠ¿åç§°åˆ—è¡¨
    """
    gesture_names = ['fist', 'open', 'left', 'right', 'rest']

    X_list = []
    y_list = []

    for label_idx, gesture in enumerate(gesture_names):
        gesture_folder = os.path.join(data_folder, gesture)
        csv_files = glob(os.path.join(gesture_folder, '*.csv'))

        print(f"åŠ è½½ {gesture}: {len(csv_files)} ä¸ªæ–‡ä»¶")

        for csv_file in csv_files:
            # è¯»å–ä¿¡å·
            data = pd.read_csv(csv_file)
            signal = data['channel_0'].values  # å‡è®¾ä½¿ç”¨ç¬¬0é€šé“

            # é¢„å¤„ç†
            signal_processed = preprocess_emg(signal, fs)

            # æå–ç‰¹å¾ï¼ˆæ»‘åŠ¨çª—å£ï¼‰
            features, _ = sliding_window_features(signal_processed,
                                                   window_size, step, fs)

            # æ·»åŠ åˆ°æ•°æ®é›†
            X_list.append(features)
            y_list.extend([label_idx] * len(features))

    # åˆå¹¶æ‰€æœ‰æ•°æ®
    X = np.vstack(X_list)
    y = np.array(y_list)

    print(f"\næ•°æ®é›†å¤§å°: {X.shape}")
    print(f"ç‰¹å¾ç»´åº¦: {X.shape[1]}")
    print(f"æ ·æœ¬æ•°: {X.shape[0]}")
    print(f"æ ‡ç­¾åˆ†å¸ƒ: {np.bincount(y)}")

    return X, y, gesture_names

# åŠ è½½æ•°æ®
X, y, gesture_names = load_gesture_dataset('data/gestures')
```

---

### 6.3 è®­ç»ƒ-æµ‹è¯•åˆ’åˆ†

**ä¸ºä»€ä¹ˆè¦åˆ’åˆ†ï¼Ÿ**
- è®­ç»ƒé›†ï¼šç”¨äºè®­ç»ƒæ¨¡å‹
- æµ‹è¯•é›†ï¼šç”¨äºè¯„ä¼°æ¨¡å‹åœ¨æ–°æ•°æ®ä¸Šçš„è¡¨ç°
- é¿å…è¿‡æ‹Ÿåˆï¼ˆæ¨¡å‹åªè®°ä½è®­ç»ƒæ•°æ®ï¼‰

**å®ç°**ï¼š
```python
from sklearn.model_selection import train_test_split

# åˆ’åˆ†æ•°æ®é›†ï¼ˆ80%è®­ç»ƒï¼Œ20%æµ‹è¯•ï¼‰
X_train, X_test, y_train, y_test = train_test_split(
    X, y,
    test_size=0.2,     # 20%ä½œä¸ºæµ‹è¯•é›†
    random_state=42,   # éšæœºç§å­ï¼Œä¿è¯å¯å¤ç°
    stratify=y         # ä¿æŒå„ç±»åˆ«æ¯”ä¾‹
)

print(f"è®­ç»ƒé›†å¤§å°: {X_train.shape}")
print(f"æµ‹è¯•é›†å¤§å°: {X_test.shape}")
print(f"è®­ç»ƒé›†æ ‡ç­¾åˆ†å¸ƒ: {np.bincount(y_train)}")
print(f"æµ‹è¯•é›†æ ‡ç­¾åˆ†å¸ƒ: {np.bincount(y_test)}")
```

**ç‰¹å¾å½’ä¸€åŒ–**ï¼š
```python
from sklearn.preprocessing import StandardScaler

# åœ¨è®­ç»ƒé›†ä¸Šæ‹Ÿåˆå½’ä¸€åŒ–å™¨
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)

# ä½¿ç”¨è®­ç»ƒé›†çš„ç»Ÿè®¡é‡è½¬æ¢æµ‹è¯•é›†
X_test_scaled = scaler.transform(X_test)
```

---

### 6.4 æ¨¡å‹è®­ç»ƒ

**éšæœºæ£®æ—åˆ†ç±»å™¨**ï¼š
```python
from sklearn.ensemble import RandomForestClassifier

# åˆ›å»ºæ¨¡å‹
clf = RandomForestClassifier(
    n_estimators=100,      # å†³ç­–æ ‘æ•°é‡
    max_depth=10,          # æ ‘çš„æœ€å¤§æ·±åº¦
    random_state=42,       # éšæœºç§å­
    n_jobs=-1              # ä½¿ç”¨æ‰€æœ‰CPUæ ¸å¿ƒ
)

# è®­ç»ƒæ¨¡å‹
print("è®­ç»ƒæ¨¡å‹...")
clf.fit(X_train_scaled, y_train)
print("è®­ç»ƒå®Œæˆ!")

# åœ¨è®­ç»ƒé›†ä¸Šè¯„ä¼°
train_accuracy = clf.score(X_train_scaled, y_train)
print(f"è®­ç»ƒé›†å‡†ç¡®ç‡: {train_accuracy*100:.2f}%")

# åœ¨æµ‹è¯•é›†ä¸Šè¯„ä¼°
test_accuracy = clf.score(X_test_scaled, y_test)
print(f"æµ‹è¯•é›†å‡†ç¡®ç‡: {test_accuracy*100:.2f}%")
```

---

### 6.5 æ¨¡å‹è¯„ä¼°

**æ··æ·†çŸ©é˜µ**ï¼š
```python
from sklearn.metrics import confusion_matrix, classification_report
import seaborn as sns

# é¢„æµ‹
y_pred = clf.predict(X_test_scaled)

# æ··æ·†çŸ©é˜µ
cm = confusion_matrix(y_test, y_pred)

# å¯è§†åŒ–
plt.figure(figsize=(10, 8))
sns.heatmap(cm, annot=True, fmt='d',
            xticklabels=gesture_names,
            yticklabels=gesture_names,
            cmap='Blues')
plt.xlabel('é¢„æµ‹æ ‡ç­¾')
plt.ylabel('çœŸå®æ ‡ç­¾')
plt.title(f'æ··æ·†çŸ©é˜µ (å‡†ç¡®ç‡: {test_accuracy*100:.1f}%)')
plt.tight_layout()
plt.savefig('confusion_matrix.png', dpi=150)
plt.show()

# è¯¦ç»†æŠ¥å‘Š
print("\nåˆ†ç±»æŠ¥å‘Š:")
print(classification_report(y_test, y_pred, target_names=gesture_names))
```

**ç‰¹å¾é‡è¦æ€§**ï¼š
```python
def plot_feature_importance(clf, feature_names, top_n=10):
    """ç»˜åˆ¶ç‰¹å¾é‡è¦æ€§"""
    importances = clf.feature_importances_
    indices = np.argsort(importances)[::-1][:top_n]

    plt.figure(figsize=(10, 6))
    plt.bar(range(top_n), importances[indices])
    plt.xticks(range(top_n),
               [feature_names[i] for i in indices],
               rotation=45, ha='right')
    plt.xlabel('ç‰¹å¾')
    plt.ylabel('é‡è¦æ€§')
    plt.title(f'Top {top_n} é‡è¦ç‰¹å¾')
    plt.tight_layout()
    plt.savefig('feature_importance.png', dpi=150)
    plt.show()

# å‡è®¾æˆ‘ä»¬æœ‰ç‰¹å¾åç§°
feature_names = ['MAV', 'RMS', 'VAR', 'WL', 'ZC', 'SSC',
                 'MNF', 'MDF', 'Peak_Freq', 'Total_Power']
plot_feature_importance(clf, feature_names, top_n=10)
```

---

### 6.6 æ¨¡å‹ä¿å­˜å’ŒåŠ è½½

**ä¿å­˜æ¨¡å‹**ï¼š
```python
import joblib

# ä¿å­˜æ¨¡å‹å’Œå½’ä¸€åŒ–å™¨
joblib.dump(clf, 'emg_classifier.pkl')
joblib.dump(scaler, 'emg_scaler.pkl')
print("æ¨¡å‹å·²ä¿å­˜")
```

**åŠ è½½æ¨¡å‹**ï¼š
```python
# åŠ è½½æ¨¡å‹
clf_loaded = joblib.load('emg_classifier.pkl')
scaler_loaded = joblib.load('emg_scaler.pkl')

# ä½¿ç”¨åŠ è½½çš„æ¨¡å‹é¢„æµ‹
def predict_gesture(signal, window_size=200, fs=1000):
    """é¢„æµ‹å•ä¸ªä¿¡å·çš„æ‰‹åŠ¿"""
    # é¢„å¤„ç†
    signal_processed = preprocess_emg(signal, fs)

    # æå–ç‰¹å¾
    features, _ = sliding_window_features(signal_processed,
                                          window_size, window_size, fs)

    # å½’ä¸€åŒ–
    features_scaled = scaler_loaded.transform(features)

    # é¢„æµ‹
    predictions = clf_loaded.predict(features_scaled)

    # å¤šæ•°æŠ•ç¥¨
    final_prediction = np.bincount(predictions).argmax()
    gesture_name = gesture_names[final_prediction]

    return gesture_name, predictions

# æµ‹è¯•
test_signal = X_test[0]  # å–ä¸€ä¸ªæµ‹è¯•ä¿¡å·
predicted_gesture, all_predictions = predict_gesture(test_signal)
print(f"é¢„æµ‹æ‰‹åŠ¿: {predicted_gesture}")
```

---

### 6.7 äº¤å‰éªŒè¯ï¼ˆè¿›é˜¶ï¼‰

**ä»€ä¹ˆæ˜¯äº¤å‰éªŒè¯ï¼Ÿ**
- å°†æ•°æ®åˆ†æˆKæŠ˜ï¼Œè½®æµä½œä¸ºæµ‹è¯•é›†
- æ›´å¯é çš„æ€§èƒ½è¯„ä¼°

**å®ç°**ï¼š
```python
from sklearn.model_selection import cross_val_score

# 5æŠ˜äº¤å‰éªŒè¯
scores = cross_val_score(clf, X, y, cv=5, scoring='accuracy')

print(f"äº¤å‰éªŒè¯å‡†ç¡®ç‡: {scores}")
print(f"å¹³å‡å‡†ç¡®ç‡: {scores.mean()*100:.2f}% (+/- {scores.std()*100:.2f}%)")
```

---

### ç¬¬8å‘¨å®è·µä½œä¸š

**ä½œä¸š1ï¼šæ•°æ®é‡‡é›†**
1. ä½¿ç”¨ä½ çš„EMGè®¾å¤‡é‡‡é›†5ç§æ‰‹åŠ¿çš„æ•°æ®
2. æ¯ç§æ‰‹åŠ¿è‡³å°‘30æ¬¡ï¼Œæ¯æ¬¡3ç§’
3. ä¿å­˜ä¸ºCSVæ ¼å¼ï¼Œç»„ç»‡æ–‡ä»¶å¤¹ç»“æ„

**ä½œä¸š2ï¼šå®Œæ•´è®­ç»ƒæµç¨‹**
1. åŠ è½½ä½ é‡‡é›†çš„æ•°æ®
2. é¢„å¤„ç†å’Œç‰¹å¾æå–
3. è®­ç»ƒéšæœºæ£®æ—åˆ†ç±»å™¨
4. è¯„ä¼°æ¨¡å‹æ€§èƒ½å¹¶ç”Ÿæˆæ··æ·†çŸ©é˜µ

**ä½œä¸š3ï¼šæ¨¡å‹ä¼˜åŒ–**
1. å°è¯•ä¸åŒçš„çª—å£å¤§å°ï¼ˆ100, 150, 200, 250 samplesï¼‰
2. å°è¯•ä¸åŒçš„ç‰¹å¾ç»„åˆï¼ˆåªç”¨æ—¶åŸŸã€åªç”¨é¢‘åŸŸã€ä¸¤è€…ç»“åˆï¼‰
3. å¯¹æ¯”å‡†ç¡®ç‡ï¼Œé€‰æ‹©æœ€ä½³é…ç½®

**ä½œä¸š4ï¼šé”™è¯¯åˆ†æ**
1. æ‰¾å‡ºåˆ†ç±»é”™è¯¯çš„æ ·æœ¬
2. å¯è§†åŒ–è¿™äº›æ ·æœ¬çš„ä¿¡å·å’Œç‰¹å¾
3. åˆ†æé”™è¯¯åŸå› ï¼ˆä¿¡å·è´¨é‡å·®ï¼Ÿæ‰‹åŠ¿ç›¸ä¼¼ï¼Ÿï¼‰

**æŒ‘æˆ˜ä½œä¸šï¼šå…¶ä»–ç®—æ³•**
1. å°è¯•ä½¿ç”¨SVMã€KNNç­‰å…¶ä»–ç®—æ³•
2. å¯¹æ¯”ä¸åŒç®—æ³•çš„æ€§èƒ½
3. ç»˜åˆ¶æ€§èƒ½å¯¹æ¯”å›¾

---

### ç¬¬8å‘¨å­¦ä¹ æ£€æŸ¥ç‚¹
âœ… ç†è§£æœºå™¨å­¦ä¹ çš„åŸºæœ¬æµç¨‹
âœ… èƒ½å‡†å¤‡å’Œç»„ç»‡è®­ç»ƒæ•°æ®
âœ… èƒ½è®­ç»ƒéšæœºæ£®æ—åˆ†ç±»å™¨
âœ… èƒ½è¯„ä¼°æ¨¡å‹æ€§èƒ½å¹¶è§£è¯»ç»“æœ
âœ… èƒ½ä¿å­˜å’ŒåŠ è½½è®­ç»ƒå¥½çš„æ¨¡å‹
âœ… ç†è§£äº¤å‰éªŒè¯çš„ä½œç”¨

---

## ğŸš€ ç¬¬ä¸ƒé˜¶æ®µï¼šå®æ—¶ç³»ç»Ÿæ­å»ºï¼ˆç¬¬9-10å‘¨ï¼‰

### å­¦ä¹ ç›®æ ‡
- å®ç°å®æ—¶EMGä¿¡å·é‡‡é›†
- æ­å»ºå®æ—¶å¤„ç†å’Œåˆ†ç±»ç³»ç»Ÿ
- å®Œæˆæœ€ç»ˆé¡¹ç›®æ¼”ç¤º

### 7.1 å®æ—¶ç³»ç»Ÿæ¶æ„

**ç³»ç»Ÿç»„æˆ**ï¼š
```
EMGè®¾å¤‡ â†’ ä¸²å£/è“ç‰™é€šä¿¡ â†’ æ•°æ®é‡‡é›†æ¨¡å— â†’
ç¼“å†²åŒº â†’ é¢„å¤„ç†æ¨¡å— â†’ ç‰¹å¾æå–æ¨¡å— â†’
åˆ†ç±»å™¨ â†’ ç»“æœæ˜¾ç¤º/äº¤äº’
```

**å…³é”®æŒ‘æˆ˜**ï¼š
- ä½å»¶è¿Ÿï¼šå¤„ç†é€Ÿåº¦è¦è·Ÿä¸Šé‡‡é›†é€Ÿåº¦
- ç¨³å®šæ€§ï¼šé•¿æ—¶é—´è¿è¡Œä¸å´©æºƒ
- å®æ—¶å¯è§†åŒ–ï¼šç»™ç”¨æˆ·å³æ—¶åé¦ˆ

---

### 7.2 å®æ—¶æ•°æ®é‡‡é›†

**ä¸²å£é€šä¿¡åŸºç¡€**ï¼š
```python
import serial
import numpy as np
from collections import deque

class EMGRealTimeAcquisition:
    """EMGå®æ—¶é‡‡é›†ç±»"""

    def __init__(self, port='COM3', baudrate=115200, buffer_size=1000):
        """
        åˆå§‹åŒ–

        å‚æ•°:
            port: ä¸²å£å·ï¼ˆWindows: 'COM3', Linux: '/dev/ttyUSB0'ï¼‰
            baudrate: æ³¢ç‰¹ç‡
            buffer_size: ç¼“å†²åŒºå¤§å°
        """
        self.port = port
        self.baudrate = baudrate
        self.buffer_size = buffer_size

        # æ•°æ®ç¼“å†²åŒº
        self.buffer = deque(maxlen=buffer_size)

        # ä¸²å£è¿æ¥
        self.serial = None
        self.is_running = False

    def connect(self):
        """è¿æ¥è®¾å¤‡"""
        try:
            self.serial = serial.Serial(self.port, self.baudrate, timeout=1)
            print(f"å·²è¿æ¥åˆ° {self.port}")
            return True
        except Exception as e:
            print(f"è¿æ¥å¤±è´¥: {e}")
            return False

    def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        if self.serial and self.serial.is_open:
            self.serial.close()
            print("å·²æ–­å¼€è¿æ¥")

    def read_sample(self):
        """è¯»å–ä¸€ä¸ªæ ·æœ¬"""
        if self.serial and self.serial.in_waiting:
            try:
                line = self.serial.readline().decode('utf-8').strip()
                value = float(line)
                return value
            except:
                return None
        return None

    def get_buffer_data(self):
        """è·å–ç¼“å†²åŒºæ•°æ®"""
        return np.array(self.buffer)

# ä½¿ç”¨ç¤ºä¾‹
acq = EMGRealTimeAcquisition(port='COM3')
if acq.connect():
    for i in range(100):
        sample = acq.read_sample()
        if sample is not None:
            print(f"Sample {i}: {sample}")
    acq.disconnect()
```

---

### 7.3 å®æ—¶å¯è§†åŒ–

**ä½¿ç”¨PyQtGraphå®æ—¶ç»˜å›¾**ï¼š
```python
import pyqtgraph as pg
from pyqtgraph.Qt import QtCore, QtWidgets
import numpy as np

class EMGRealTimePlotter:
    """EMGå®æ—¶ç»˜å›¾ç±»"""

    def __init__(self, window_size=1000, fs=1000):
        self.window_size = window_size
        self.fs = fs

        # åˆå§‹åŒ–æ•°æ®
        self.data = np.zeros(window_size)
        self.data_filtered = np.zeros(window_size)

        # åˆ›å»ºåº”ç”¨å’Œçª—å£
        self.app = QtWidgets.QApplication([])
        self.win = pg.GraphicsLayoutWidget(show=True, title="EMG Real-Time Monitor")
        self.win.resize(1200, 600)

        # åˆ›å»ºç»˜å›¾åŒºåŸŸ
        self.plot_raw = self.win.addPlot(title="åŸå§‹ä¿¡å·")
        self.plot_raw.setYRange(-5, 5)
        self.plot_raw.setLabel('left', 'Amplitude', units='mV')
        self.plot_raw.setLabel('bottom', 'Time', units='s')
        self.curve_raw = self.plot_raw.plot(pen='y')

        self.win.nextRow()

        self.plot_filtered = self.win.addPlot(title="æ»¤æ³¢åä¿¡å·")
        self.plot_filtered.setYRange(-2, 2)
        self.plot_filtered.setLabel('left', 'Amplitude', units='mV')
        self.plot_filtered.setLabel('bottom', 'Time', units='s')
        self.curve_filtered = self.plot_filtered.plot(pen='g')

        # æ—¶é—´è½´
        self.time = np.linspace(0, window_size/fs, window_size)

    def update(self, new_sample):
        """æ›´æ–°æ•°æ®å’Œå›¾è¡¨"""
        # æ»šåŠ¨æ•°æ®
        self.data[:-1] = self.data[1:]
        self.data[-1] = new_sample

        # æ»¤æ³¢
        self.data_filtered = bandpass_filter(self.data, fs=self.fs)

        # æ›´æ–°æ›²çº¿
        self.curve_raw.setData(self.time, self.data)
        self.curve_filtered.setData(self.time, self.data_filtered)

    def run(self):
        """è¿è¡Œåº”ç”¨"""
        self.app.exec_()

# ä½¿ç”¨ç¤ºä¾‹
plotter = EMGRealTimePlotter(window_size=1000, fs=1000)

# æ¨¡æ‹Ÿæ•°æ®æµ
def update_plot():
    sample = np.random.randn() * 0.5  # æ¨¡æ‹Ÿé‡‡é›†
    plotter.update(sample)

timer = QtCore.QTimer()
timer.timeout.connect(update_plot)
timer.start(10)  # 100Hzæ›´æ–°

plotter.run()
```

---

### 7.4 å®æ—¶åˆ†ç±»ç³»ç»Ÿ

**å®Œæ•´çš„å®æ—¶æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ**ï¼š
```python
class EMGRealTimeClassifier:
    """EMGå®æ—¶åˆ†ç±»ç³»ç»Ÿ"""

    def __init__(self, model_path, scaler_path,
                 window_size=200, fs=1000):
        # åŠ è½½æ¨¡å‹
        self.clf = joblib.load(model_path)
        self.scaler = joblib.load(scaler_path)

        self.window_size = window_size
        self.fs = fs

        # æ‰‹åŠ¿åç§°
        self.gesture_names = ['fist', 'open', 'left', 'right', 'rest']

        # æ•°æ®ç¼“å†²åŒº
        self.buffer = deque(maxlen=window_size)

        # é¢„æµ‹å†å²ï¼ˆå¹³æ»‘ï¼‰
        self.prediction_history = deque(maxlen=5)

    def add_sample(self, sample):
        """æ·»åŠ æ–°æ ·æœ¬"""
        self.buffer.append(sample)

    def predict(self):
        """å®æ—¶é¢„æµ‹"""
        if len(self.buffer) < self.window_size:
            return None, None

        # è·å–çª—å£æ•°æ®
        window = np.array(self.buffer)

        # é¢„å¤„ç†
        window_processed = bandpass_filter(window, fs=self.fs)

        # æå–ç‰¹å¾
        features = extract_time_features(window_processed)
        freq_features = extract_freq_features(window_processed, self.fs)

        # åˆå¹¶ç‰¹å¾
        feature_vector = np.array([
            features['MAV'], features['RMS'], features['VAR'],
            features['WL'], features['ZC'], features['SSC'],
            freq_features['MNF'], freq_features['MDF']
        ]).reshape(1, -1)

        # å½’ä¸€åŒ–
        feature_scaled = self.scaler.transform(feature_vector)

        # é¢„æµ‹
        prediction = self.clf.predict(feature_scaled)[0]
        confidence = self.clf.predict_proba(feature_scaled)[0]

        # æ·»åŠ åˆ°å†å²
        self.prediction_history.append(prediction)

        # å¤šæ•°æŠ•ç¥¨å¹³æ»‘
        if len(self.prediction_history) == 5:
            smoothed_prediction = np.bincount(self.prediction_history).argmax()
            gesture_name = self.gesture_names[smoothed_prediction]
            gesture_confidence = confidence[smoothed_prediction]

            return gesture_name, gesture_confidence

        return None, None

# ä½¿ç”¨ç¤ºä¾‹
classifier = EMGRealTimeClassifier('emg_classifier.pkl',
                                   'emg_scaler.pkl')

# å®æ—¶åˆ†ç±»å¾ªç¯
while True:
    sample = acq.read_sample()  # ä»é‡‡é›†å™¨è¯»å–
    if sample is not None:
        classifier.add_sample(sample)
        gesture, confidence = classifier.predict()
        if gesture:
            print(f"æ£€æµ‹åˆ°: {gesture} (ç½®ä¿¡åº¦: {confidence*100:.1f}%)")
```

---

### 7.5 å®Œæ•´å®æ—¶ç³»ç»Ÿæ•´åˆ

**ç»¼åˆç³»ç»Ÿï¼ˆé‡‡é›†+å¯è§†åŒ–+åˆ†ç±»ï¼‰**ï¼š
```python
class EMGRealTimeSystem:
    """EMGå®Œæ•´å®æ—¶ç³»ç»Ÿ"""

    def __init__(self, port='COM3', model_path='emg_classifier.pkl',
                 scaler_path='emg_scaler.pkl'):
        # é‡‡é›†å™¨
        self.acq = EMGRealTimeAcquisition(port=port)

        # åˆ†ç±»å™¨
        self.classifier = EMGRealTimeClassifier(model_path, scaler_path)

        # å¯è§†åŒ–
        self.plotter = EMGRealTimePlotter()

        # å½“å‰æ‰‹åŠ¿
        self.current_gesture = "æœªçŸ¥"
        self.current_confidence = 0.0

        # æ·»åŠ æ‰‹åŠ¿æ˜¾ç¤ºæ–‡æœ¬
        self.gesture_text = pg.TextItem(text="", anchor=(0, 1))
        self.plotter.plot_raw.addItem(self.gesture_text)
        self.gesture_text.setPos(0, 4)

    def update(self):
        """æ›´æ–°å‡½æ•°ï¼ˆç”±å®šæ—¶å™¨è°ƒç”¨ï¼‰"""
        # è¯»å–æ ·æœ¬
        sample = self.acq.read_sample()
        if sample is not None:
            # æ›´æ–°å¯è§†åŒ–
            self.plotter.update(sample)

            # æ·»åŠ åˆ°åˆ†ç±»å™¨
            self.classifier.add_sample(sample)

            # é¢„æµ‹
            gesture, confidence = self.classifier.predict()
            if gesture:
                self.current_gesture = gesture
                self.current_confidence = confidence

                # æ›´æ–°æ˜¾ç¤º
                text = f"æ‰‹åŠ¿: {gesture}\nç½®ä¿¡åº¦: {confidence*100:.1f}%"
                self.gesture_text.setText(text)

    def run(self):
        """è¿è¡Œç³»ç»Ÿ"""
        if not self.acq.connect():
            print("æ— æ³•è¿æ¥è®¾å¤‡")
            return

        # è®¾ç½®å®šæ—¶å™¨
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update)
        self.timer.start(10)  # 100Hz

        print("ç³»ç»Ÿè¿è¡Œä¸­... æŒ‰Ctrl+Cåœæ­¢")

        try:
            self.plotter.run()
        except KeyboardInterrupt:
            print("\nåœæ­¢ç³»ç»Ÿ")
        finally:
            self.acq.disconnect()

# å¯åŠ¨ç³»ç»Ÿ
if __name__ == '__main__':
    system = EMGRealTimeSystem(port='COM3')
    system.run()
```

---

### 7.6 æœ€ç»ˆé¡¹ç›®ï¼šEMGæ§åˆ¶åº”ç”¨

**é¡¹ç›®é€‰é¡¹**ï¼š

**é€‰é¡¹1ï¼šEMGæ§åˆ¶çš„æ¸¸æˆ**
```python
import pygame

class EMGGameController:
    """ä½¿ç”¨EMGæ§åˆ¶çš„ç®€å•æ¸¸æˆ"""

    def __init__(self, classifier):
        pygame.init()
        self.screen = pygame.display.set_mode((800, 600))
        self.clock = pygame.time.Clock()
        self.classifier = classifier

        # æ¸¸æˆå¯¹è±¡
        self.player_y = 300
        self.target_y = 300

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

            # è¯»å–EMGæ‰‹åŠ¿
            gesture, _ = self.classifier.predict()

            # æ ¹æ®æ‰‹åŠ¿æ§åˆ¶
            if gesture == 'fist':
                self.target_y -= 5
            elif gesture == 'open':
                self.target_y += 5

            # å¹³æ»‘ç§»åŠ¨
            self.player_y += (self.target_y - self.player_y) * 0.1

            # ç»˜åˆ¶
            self.screen.fill((0, 0, 0))
            pygame.draw.circle(self.screen, (255, 0, 0),
                              (400, int(self.player_y)), 30)
            pygame.display.flip()
            self.clock.tick(60)

        pygame.quit()
```

**é€‰é¡¹2ï¼šEMGè‚Œè‚‰è®­ç»ƒç›‘æµ‹**
```python
class EMGTrainingMonitor:
    """è‚Œè‚‰è®­ç»ƒç›‘æµ‹åº”ç”¨"""

    def __init__(self):
        self.session_data = []
        self.reps_count = 0
        self.is_contracted = False
        self.threshold = 0.5

    def monitor(self, rms_value):
        """ç›‘æµ‹è‚Œè‚‰æ”¶ç¼©"""
        # æ£€æµ‹æ”¶ç¼©å¼€å§‹
        if rms_value > self.threshold and not self.is_contracted:
            self.is_contracted = True
            self.reps_count += 1
            print(f"ç¬¬ {self.reps_count} æ¬¡æ”¶ç¼©")

        # æ£€æµ‹æ”¾æ¾
        elif rms_value < self.threshold * 0.7 and self.is_contracted:
            self.is_contracted = False

        # è®°å½•æ•°æ®
        self.session_data.append({
            'time': len(self.session_data) / 100,  # å‡è®¾100Hz
            'rms': rms_value,
            'is_contracted': self.is_contracted
        })

    def generate_report(self):
        """ç”Ÿæˆè®­ç»ƒæŠ¥å‘Š"""
        df = pd.DataFrame(self.session_data)

        fig, axes = plt.subplots(2, 1, figsize=(12, 8))

        # RMSæ—¶é—´åºåˆ—
        axes[0].plot(df['time'], df['rms'])
        axes[0].axhline(self.threshold, color='r', linestyle='--',
                       label='é˜ˆå€¼')
        axes[0].set_ylabel('RMS')
        axes[0].set_title(f'è®­ç»ƒæŠ¥å‘Š - æ€»è®¡ {self.reps_count} æ¬¡æ”¶ç¼©')
        axes[0].legend()
        axes[0].grid(True)

        # æ”¶ç¼©çŠ¶æ€
        axes[1].fill_between(df['time'], df['is_contracted'],
                            alpha=0.5, label='æ”¶ç¼©çŠ¶æ€')
        axes[1].set_xlabel('æ—¶é—´ (s)')
        axes[1].set_ylabel('çŠ¶æ€')
        axes[1].set_yticks([0, 1])
        axes[1].set_yticklabels(['æ”¾æ¾', 'æ”¶ç¼©'])
        axes[1].grid(True)

        plt.tight_layout()
        plt.savefig('training_report.png', dpi=150)
        plt.show()
```

---

### ç¬¬9-10å‘¨å®è·µé¡¹ç›®

**æ ¸å¿ƒé¡¹ç›®ï¼šå®æ—¶æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ**
1. æ­å»ºå®Œæ•´çš„å®æ—¶é‡‡é›†ã€å¤„ç†ã€åˆ†ç±»ç³»ç»Ÿ
2. å®ç°å®æ—¶å¯è§†åŒ–ç•Œé¢
3. è‡³å°‘è¯†åˆ«3ç§ä¸åŒæ‰‹åŠ¿
4. ç³»ç»Ÿå»¶è¿Ÿå°äº100ms
5. åˆ†ç±»å‡†ç¡®ç‡é«˜äº80%

**æ‰©å±•é¡¹ç›®ï¼ˆé€‰å…¶ä¸€ï¼‰**ï¼š
1. **EMGæ§åˆ¶æ¸¸æˆ**: ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶ä¸€ä¸ªç®€å•æ¸¸æˆ
2. **è‚Œè‚‰è®­ç»ƒåŠ©æ‰‹**: ç›‘æµ‹å’Œè®°å½•è‚Œè‚‰è®­ç»ƒè¿‡ç¨‹
3. **ç–²åŠ³ç›‘æµ‹ç³»ç»Ÿ**: å®æ—¶ç›‘æµ‹è‚Œè‚‰ç–²åŠ³ç¨‹åº¦
4. **å¤šäººååŒ**: å¤šä¸ªEMGè®¾å¤‡åŒæ—¶é‡‡é›†å’Œåˆ†æ

**é¡¹ç›®äº¤ä»˜ç‰©**ï¼š
1. å®Œæ•´å¯è¿è¡Œçš„ä»£ç 
2. ç³»ç»Ÿæ¼”ç¤ºè§†é¢‘ï¼ˆ3-5åˆ†é’Ÿï¼‰
3. æŠ€æœ¯æŠ¥å‘Šï¼š
   - ç³»ç»Ÿæ¶æ„è¯´æ˜
   - ç®—æ³•é€‰æ‹©å’Œä¼˜åŒ–è¿‡ç¨‹
   - æ€§èƒ½æµ‹è¯•ç»“æœ
   - é‡åˆ°çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
4. ç”¨æˆ·ä½¿ç”¨è¯´æ˜ä¹¦

---

### ç¬¬9-10å‘¨å­¦ä¹ æ£€æŸ¥ç‚¹
âœ… èƒ½å®ç°å®æ—¶æ•°æ®é‡‡é›†
âœ… èƒ½æ­å»ºå®æ—¶å¯è§†åŒ–ç³»ç»Ÿ
âœ… èƒ½é›†æˆåˆ†ç±»å™¨è¿›è¡Œå®æ—¶è¯†åˆ«
âœ… ç³»ç»Ÿè¿è¡Œç¨³å®šï¼Œå»¶è¿Ÿä½
âœ… å®Œæˆæœ€ç»ˆé¡¹ç›®å¹¶èƒ½æ¼”ç¤º

---

## ğŸ“ è¯„ä¼°æ ‡å‡†

### è¿‡ç¨‹è¯„ä¼°ï¼ˆ40%ï¼‰
- æ¯å‘¨ä½œä¸šå®Œæˆæƒ…å†µ
- ä»£ç è´¨é‡å’Œè§„èŒƒæ€§
- å­¦ä¹ ç¬”è®°å’Œé—®é¢˜è®°å½•

### æœ€ç»ˆé¡¹ç›®ï¼ˆ60%ï¼‰
- **åŠŸèƒ½å®Œæ•´æ€§ï¼ˆ20%ï¼‰**: ç³»ç»Ÿèƒ½æ­£å¸¸è¿è¡Œï¼Œå®ç°åŸºæœ¬åŠŸèƒ½
- **æŠ€æœ¯æ·±åº¦ï¼ˆ15%ï¼‰**: ç®—æ³•ç†è§£æ·±åº¦ï¼Œä»£ç è´¨é‡
- **æ€§èƒ½æŒ‡æ ‡ï¼ˆ15%ï¼‰**: åˆ†ç±»å‡†ç¡®ç‡ã€å»¶è¿Ÿã€ç¨³å®šæ€§
- **åˆ›æ–°æ€§ï¼ˆ10%ï¼‰**: é¢å¤–åŠŸèƒ½ã€ä¼˜åŒ–ã€åˆ›æ„åº”ç”¨

---

## ğŸ› ï¸ æ¨èå·¥å…·å’Œèµ„æº

### å¼€å‘ç¯å¢ƒ
- **Python**: Anaconda 3.9+
- **IDE**: VS Code æˆ– PyCharm
- **ç‰ˆæœ¬æ§åˆ¶**: Git + GitHub

### ç¡¬ä»¶å»ºè®®
- **å…¥é—¨**: Arduino + Grove EMG Sensor ($40)
- **æ¨è**: MyoWare Muscle Sensor ($40) + Arduino
- **è¿›é˜¶**: OpenBCI Cyton (8é€šé“, $500)

### å­¦ä¹ èµ„æº
- **åœ¨çº¿è¯¾ç¨‹**: Coursera "Digital Signal Processing"
- **ä¹¦ç±**: "Biomedical Signal Analysis" by Rangaraj M. Rangayyan
- **æ•°æ®é›†**:
  - Ninapro Databaseï¼ˆå…¬å¼€EMGæ•°æ®é›†ï¼‰
  - PhysioNet EMG Database
- **è®ºæ–‡æ•°æ®åº“**: Google Scholar, PubMed

### ç¤¾åŒºå’Œè®ºå›
- **Reddit**: r/bioengineering, r/machinelearning
- **Stack Overflow**: ä»£ç é—®é¢˜æ±‚åŠ©
- **GitHub**: å‚è€ƒå¼€æºEMGé¡¹ç›®

---

## ğŸ“… æ—¶é—´ç®¡ç†å»ºè®®

**æ¯å‘¨æ—¶é—´åˆ†é…**ï¼š
- ç†è®ºå­¦ä¹ ï¼š3-4å°æ—¶
- ç¼–ç¨‹å®è·µï¼š4-5å°æ—¶
- ä½œä¸šå®Œæˆï¼š2-3å°æ—¶
- æ€»è®¡ï¼š10-12å°æ—¶/å‘¨

**å­¦ä¹ èŠ‚å¥**ï¼š
- **å‰3å‘¨**: ä»¥ç†è§£ä¸ºä¸»ï¼Œä¸æ€¥äºç¼–ç¨‹
- **ç¬¬4-5å‘¨**: é›†ä¸­æ”»å…‹PythonåŸºç¡€
- **ç¬¬6-7å‘¨**: æ·±å…¥ä¿¡å·å¤„ç†
- **ç¬¬8å‘¨**: æŒæ¡æœºå™¨å­¦ä¹ 
- **ç¬¬9-10å‘¨**: å…¨åŠ›å®Œæˆé¡¹ç›®

**é¿å…å¸¸è§é™·é˜±**ï¼š
- âŒ è·³è¿‡åŸºç¡€ç›´æ¥åšé¡¹ç›®
- âŒ åªçœ‹ä¸ç»ƒï¼Œæ²¡æœ‰ä»£ç ç§¯ç´¯
- âŒ é‡åˆ°å›°éš¾å°±æ”¾å¼ƒ
- âœ… å¾ªåºæ¸è¿›ï¼Œæ¯å¤©è¿›æ­¥ä¸€ç‚¹
- âœ… å¤šåŠ¨æ‰‹å®è·µï¼Œè°ƒè¯•ä»£ç 
- âœ… è®°å½•é—®é¢˜ï¼Œå¯»æ±‚å¸®åŠ©

---

## ğŸ“ å­¦ä¹ æˆæœå±•ç¤º

å®Œæˆæœ¬è¯¾ç¨‹åï¼Œå­¦ç”Ÿå°†èƒ½å¤Ÿï¼š

1. âœ… è§£é‡ŠEMGä¿¡å·çš„äº§ç”Ÿå’Œç‰¹å¾
2. âœ… ç‹¬ç«‹æ­å»ºEMGé‡‡é›†ç³»ç»Ÿ
3. âœ… ä½¿ç”¨Pythonå¤„ç†å’Œåˆ†æEMGæ•°æ®
4. âœ… å®ç°ä¿¡å·æ»¤æ³¢å’Œç‰¹å¾æå–
5. âœ… è®­ç»ƒæœºå™¨å­¦ä¹ æ¨¡å‹è¿›è¡Œæ‰‹åŠ¿è¯†åˆ«
6. âœ… æ­å»ºå®Œæ•´çš„å®æ—¶EMGå¤„ç†ç³»ç»Ÿ
7. âœ… å®Œæˆä¸€ä¸ªå®é™…çš„EMGåº”ç”¨é¡¹ç›®

**å¯å±•ç¤ºçš„ä½œå“**ï¼š
- GitHubä»£ç ä»“åº“
- é¡¹ç›®æ¼”ç¤ºè§†é¢‘
- æŠ€æœ¯åšå®¢æ–‡ç« 
- é¡¹ç›®æŠ¥å‘ŠPDF

---

## ğŸ’¬ å¯¼å¸ˆæŒ‡å¯¼å»ºè®®

### æ•™å­¦è¦ç‚¹
1. **å¼ºè°ƒå¯è§†åŒ–**: æ¯ä¸ªæ¦‚å¿µéƒ½è¦æœ‰å›¾ç¤ºå’Œä»£ç è¾“å‡º
2. **ä»ç®€å•å¼€å§‹**: å…ˆç”¨æ¨¡æ‹Ÿæ•°æ®ï¼Œå†ç”¨çœŸå®æ•°æ®
3. **åŠæ—¶åé¦ˆ**: æ¯å‘¨æ£€æŸ¥ä½œä¸šï¼Œç»™å‡ºå…·ä½“å»ºè®®
4. **é¼“åŠ±æ¢ç´¢**: å…è®¸å­¦ç”Ÿå°è¯•è‡ªå·±çš„æƒ³æ³•
5. **å®è·µä¼˜å…ˆ**: ç†è®ºè®²è§£ä¸è¶…è¿‡30%æ—¶é—´

### å¸¸è§éš¾ç‚¹å’Œåº”å¯¹
- **éš¾ç‚¹1ï¼šPythonè¯­æ³•**: æä¾›å¤§é‡ç¤ºä¾‹ä»£ç ï¼Œé¼“åŠ±æ¨¡ä»¿
- **éš¾ç‚¹2ï¼šä¿¡å·å¤„ç†æ¦‚å¿µ**: ä½¿ç”¨åŠ¨ç”»å’Œäº¤äº’å¼æ¼”ç¤º
- **éš¾ç‚¹3ï¼šè°ƒè¯•ç¡¬ä»¶**: æå‰æµ‹è¯•è®¾å¤‡ï¼Œå‡†å¤‡å¤‡ç”¨æ–¹æ¡ˆ
- **éš¾ç‚¹4ï¼šé¡¹ç›®æ•´åˆ**: æä¾›å®Œæ•´æ¡†æ¶ï¼Œå­¦ç”Ÿå¡«å……åŠŸèƒ½

### è¿›åº¦è·Ÿè¸ª
- æ¯å‘¨ä¸€æ¬¡è¿›åº¦ä¼šè®®ï¼ˆ30åˆ†é’Ÿï¼‰
- æ¯ä¸¤å‘¨ä¸€æ¬¡ä»£ç å®¡æŸ¥
- ç¬¬5å‘¨ä¸­æœŸæ£€æŸ¥
- ç¬¬10å‘¨æœ€ç»ˆç­”è¾©

---

## ğŸ“– é™„å½•

### A. Pythoné€ŸæŸ¥è¡¨
```python
# å¸¸ç”¨NumPyæ“ä½œ
np.array([1, 2, 3])         # åˆ›å»ºæ•°ç»„
np.zeros(100)               # å…¨é›¶æ•°ç»„
np.mean(arr)                # å¹³å‡å€¼
np.std(arr)                 # æ ‡å‡†å·®
arr[10:20]                  # åˆ‡ç‰‡
arr > 0.5                   # å¸ƒå°”ç´¢å¼•

# å¸¸ç”¨Matplotlibæ“ä½œ
plt.plot(x, y)              # æŠ˜çº¿å›¾
plt.xlabel('X')             # xè½´æ ‡ç­¾
plt.title('Title')          # æ ‡é¢˜
plt.grid(True)              # ç½‘æ ¼
plt.savefig('plot.png')     # ä¿å­˜å›¾ç‰‡
plt.show()                  # æ˜¾ç¤ºå›¾ç‰‡
```

### B. æœ¯è¯­è¡¨
- **EMG**: è‚Œç”µå›¾ï¼ˆElectromyographyï¼‰
- **ADC**: æ¨¡æ•°è½¬æ¢å™¨ï¼ˆAnalog-to-Digital Converterï¼‰
- **FFT**: å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFast Fourier Transformï¼‰
- **RMS**: å‡æ–¹æ ¹ï¼ˆRoot Mean Squareï¼‰
- **SNR**: ä¿¡å™ªæ¯”ï¼ˆSignal-to-Noise Ratioï¼‰
- **MNF**: å¹³å‡é¢‘ç‡ï¼ˆMean Frequencyï¼‰
- **MDF**: ä¸­å€¼é¢‘ç‡ï¼ˆMedian Frequencyï¼‰

### C. æ•…éšœæ’é™¤æŒ‡å—
| é—®é¢˜ | å¯èƒ½åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|---------|---------|
| ä¿¡å·è´¨é‡å·® | ç”µææ¥è§¦ä¸è‰¯ | æ¸…æ´çš®è‚¤ï¼Œä½¿ç”¨å¯¼ç”µè† |
| å·¥é¢‘å¹²æ‰°ä¸¥é‡ | æ¥åœ°ä¸è‰¯ | æ£€æŸ¥è®¾å¤‡æ¥åœ° |
| åˆ†ç±»å‡†ç¡®ç‡ä½ | ç‰¹å¾é€‰æ‹©ä¸å½“ | å°è¯•æ›´å¤šç‰¹å¾ç»„åˆ |
| å®æ—¶ç³»ç»Ÿå¡é¡¿ | å¤„ç†é€Ÿåº¦æ…¢ | ä¼˜åŒ–ç®—æ³•ï¼Œé™ä½é‡‡æ ·ç‡ |

---

## ğŸ¯ æœ€åçš„è¯

è¿™ä¸ªå­¦ä¹ è®¡åˆ’è®¾è®¡ä¸ºå¾ªåºæ¸è¿›ã€ç†è®ºç»“åˆå®è·µã€‚å…³é”®æ˜¯ï¼š
- **ä¸è¦ç€æ€¥**: æ¯ä¸ªé˜¶æ®µéƒ½è¦æ‰“ç‰¢åŸºç¡€
- **å¤šåŠ¨æ‰‹**: ç¼–ç¨‹èƒ½åŠ›åªèƒ½é€šè¿‡å®è·µæå‡
- **æ•¢äºå°è¯•**: å¤±è´¥æ˜¯å­¦ä¹ çš„ä¸€éƒ¨åˆ†
- **å¯»æ±‚å¸®åŠ©**: é‡åˆ°é—®é¢˜åŠæ—¶å‘å¯¼å¸ˆæˆ–ç¤¾åŒºæ±‚åŠ©

è®°ä½ï¼Œå­¦ä¹ EMGä¿¡å·å¤„ç†ä¸ä»…ä»…æ˜¯ä¸ºäº†å®Œæˆä¸€ä¸ªé¡¹ç›®ï¼Œæ›´æ˜¯ä¸ºäº†ï¼š
- åŸ¹å…»ç§‘å­¦æ€ç»´å’Œå·¥ç¨‹èƒ½åŠ›
- ç†è§£ç”Ÿç‰©ä¿¡å·ä¸è®¡ç®—æœºçš„æ¡¥æ¢
- ä¸ºæœªæ¥åœ¨ç”Ÿç‰©åŒ»å­¦å·¥ç¨‹ã€äººæœºäº¤äº’ç­‰é¢†åŸŸæ‰“ä¸‹åŸºç¡€

ç¥å­¦ä¹ æ„‰å¿«ï¼Œé¡¹ç›®æˆåŠŸï¼ğŸš€

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æ›´æ–°æ—¥æœŸ**: 2026å¹´
**ä½œè€…**: [å¯¼å¸ˆå§“å]
**è”ç³»æ–¹å¼**: [é‚®ç®±]
